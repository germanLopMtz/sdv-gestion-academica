<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.16.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: C:/Users/annaa/OneDrive/Desktop/sdv-gestion-academica/sdv-frontend/node_modules/zod Directory Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.16.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('dir_0328c5866053b935528d6ba1a92bb593.html','',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">zod Directory Reference</div></div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p align="center"></p>
<p><img src="logo.svg" alt="Zod logo" width="200px" align="center" style="pointer-events: none;" class="inline"/> </p><h1 align="center">Zod</h1>
<p align="center"></p>
<p>‚ú® <a href="https://zod.dev">https://zod.dev</a> ‚ú® <br  />
 TypeScript-first schema validation with static type inference </p>
<p align="center"><br  />
 </p>
<p><a href="https://github.com/colinhacks/zod/actions?query=branch%3Amaster"><img src="https://github.com/colinhacks/zod/actions/workflows/test.yml/badge.svg?event=push&amp;branch=master" alt="Zod CI status" style="pointer-events: none;" class="inline"/></a> <a href="https://twitter.com/colinhacks" rel="nofollow"><img src="https://img.shields.io/badge/created%20by-@colinhacks-4BBAAB.svg" alt="Created by Colin McDonnell" style="pointer-events: none;" class="inline"/></a> <a href="https://opensource.org/licenses/MIT" rel="nofollow"><img src="https://img.shields.io/github/license/colinhacks/zod" alt="License" class="inline"/></a> <a href="https://www.npmjs.com/package/zod" rel="nofollow"><img src="https://img.shields.io/npm/dw/zod.svg" alt="npm" style="pointer-events: none;" class="inline"/></a> <a href="https://www.npmjs.com/package/zod" rel="nofollow"><img src="https://img.shields.io/github/stars/colinhacks/zod" alt="stars" class="inline"/></a> <a href="https://discord.gg/KaSRdyX2vc" rel="nofollow"><img src="https://img.shields.io/discord/893487829802418277?label=Discord&amp;logo=discord&amp;logoColor=white" alt="discord server" class="inline"/></a> </p>
<div align="center"> <a href="https://zod.dev">Documentation</a> <span>&#160;&#160;‚Ä¢&#160;&#160;</span> <a href="https://discord.gg/RcG33DQJdf">Discord</a> <span>&#160;&#160;‚Ä¢&#160;&#160;</span> <a href="https://www.npmjs.com/package/zod">npm</a> <span>&#160;&#160;‚Ä¢&#160;&#160;</span> <a href="https://deno.land/x/zod">deno</a> <span>&#160;&#160;‚Ä¢&#160;&#160;</span> <a href="https://github.com/colinhacks/zod/issues/new">Issues</a> <span>&#160;&#160;‚Ä¢&#160;&#160;</span> <a href="https://twitter.com/colinhacks">@colinhacks</a> <span>&#160;&#160;‚Ä¢&#160;&#160;</span> <a href="https://trpc.io">tRPC</a> <br  />
 </div><p><br  />
 <br  />
</p>
<blockquote class="doxtable">
<p>Zod 3.23 is out! View the <a href="https://github.com/colinhacks/zod/releases/tag/v3.23.0">release notes</a>. </p>
</blockquote>
<blockquote class="doxtable">
<p>These docs have been translated into Chinese. </p>
</blockquote>
<h2 class="doxsection"><a class="anchor" id="autotoc_md7849"></a>
Table of contents</h2>
<ul>
<li>Table of contents</li>
<li>Introduction<ul>
<li>Sponsors<ul>
<li>Gold</li>
<li>Silver</li>
<li>Bronze</li>
<li>Copper</li>
</ul>
</li>
<li>Ecosystem<ul>
<li>Resources</li>
<li>API libraries</li>
<li>Form integrations</li>
<li>Zod to X</li>
<li>X to Zod</li>
<li>Mocking</li>
<li>Powered by Zod</li>
<li>Utilities for Zod</li>
</ul>
</li>
</ul>
</li>
<li>Installation<ul>
<li>Requirements</li>
<li>From `npm` (Node/Bun)</li>
<li>From `deno.land/x` (Deno)</li>
</ul>
</li>
<li>Basic usage</li>
<li>Primitives</li>
<li>Coercion for primitives</li>
<li>Literals</li>
<li>Strings<ul>
<li>Datetimes</li>
<li>Dates</li>
<li>Times</li>
<li>IP addresses</li>
</ul>
</li>
<li>Numbers</li>
<li>BigInts</li>
<li>NaNs</li>
<li>Booleans</li>
<li>Dates</li>
<li>Zod enums</li>
<li>Native enums</li>
<li>Optionals</li>
<li>Nullables</li>
<li>Objects<ul>
<li>`.shape`</li>
<li>`.keyof`</li>
<li>`.extend`</li>
<li><a class="el" href="dir_9547f609d9a07adece9b17c49bbcb334.html#merge" title="merge">`.merge`</a></li>
<li>`.pick/.omit`</li>
<li>`.partial`</li>
<li>`.deepPartial`</li>
<li>`.required`</li>
<li>`.passthrough`</li>
<li>`.strict`</li>
<li>`.strip`</li>
<li>`.catchall`</li>
</ul>
</li>
<li>Arrays<ul>
<li>`.element`</li>
<li>`.nonempty`</li>
<li>`.min/.max/.length`</li>
</ul>
</li>
<li>Tuples</li>
<li>Unions</li>
<li>Discriminated unions</li>
<li>Records<ul>
<li>Record key type</li>
</ul>
</li>
<li>Maps</li>
<li>Sets</li>
<li>Intersections</li>
<li>Recursive types<ul>
<li>ZodType with ZodEffects</li>
<li>JSON type</li>
<li>Cyclical objects</li>
</ul>
</li>
<li>Promises</li>
<li>Instanceof</li>
<li>Functions</li>
<li>Preprocess</li>
<li>Custom schemas</li>
<li>Schema methods<ul>
<li>`.parse`</li>
<li>`.parseAsync`</li>
<li>`.safeParse`</li>
<li>`.safeParseAsync`</li>
<li>`.refine`<ul>
<li>Arguments</li>
<li>Customize error path</li>
<li>Asynchronous refinements</li>
<li>Relationship to transforms</li>
</ul>
</li>
<li>`.superRefine`<ul>
<li>Abort early</li>
<li>Type refinements</li>
</ul>
</li>
<li>`.transform`<ul>
<li>Chaining order</li>
<li>Validating during transform</li>
<li>Relationship to refinements</li>
<li>Async transforms</li>
</ul>
</li>
<li>`.default`</li>
<li>`.describe`</li>
<li>`.catch`</li>
<li>`.optional`</li>
<li>`.nullable`</li>
<li>`.nullish`</li>
<li>`.array`</li>
<li><a class="el" href="dir_6c35bbf451ccf39e854c65af653dc4e9.html#promise" title="promise">`.promise`</a></li>
<li>`.or`</li>
<li>`.and`</li>
<li>`.brand`</li>
<li>`.readonly`</li>
<li>`.pipe`<ul>
<li>You can use `.pipe()` to fix common issues with `z.coerce`.</li>
</ul>
</li>
</ul>
</li>
<li>Guides and concepts<ul>
<li>Type inference</li>
<li>Writing generic functions<ul>
<li>Constraining allowable inputs</li>
</ul>
</li>
<li>Error handling</li>
<li>Error formatting</li>
</ul>
</li>
<li>Comparison<ul>
<li>Joi</li>
<li>Yup</li>
<li>io-ts</li>
<li>Runtypes</li>
<li>Ow</li>
</ul>
</li>
<li>Changelog</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md7851"></a>
Introduction</h2>
<p>Zod is a TypeScript-first schema declaration and validation library. I'm using the term "schema" to broadly refer to any data type, from a simple <span class="tt">string</span> to a complex nested object.</p>
<p>Zod is designed to be as developer-friendly as possible. The goal is to eliminate duplicative type declarations. With Zod, you declare a validator <em>once</em> and Zod will automatically infer the static TypeScript type. It's easy to compose simpler types into complex data structures.</p>
<p>Some other great aspects:</p>
<ul>
<li>Zero dependencies</li>
<li>Works in Node.js and all modern browsers</li>
<li>Tiny: 8kb minified + zipped</li>
<li>Immutable: methods (e.g. <span class="tt">.optional()</span>) return a new instance</li>
<li>Concise, chainable interface</li>
<li>Functional approach: <a href="https://lexi-lambda.github.io/blog/2019/11/05/parse-don-t-validate/">parse, don't validate</a></li>
<li>Works with plain JavaScript too! You don't need to use TypeScript.</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md7852"></a>
Sponsors</h3>
<p>Sponsorship at any level is appreciated and encouraged. For individual developers, consider the <a href="https://github.com/sponsors/colinhacks">Cup of Coffee tier</a>. If you built a paid product using Zod, consider one of the <a href="https://github.com/sponsors/colinhacks">podium tiers</a>.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md7853"></a>
Platinum</h4>
<blockquote class="doxtable">
<p><a href="#" onclick="location.href='mai'+'lto:'+'col'+'in'+'@co'+'li'+'nha'+'ck'+'s.c'+'om'; return false;">Email me</a> to discuss sponsoring Zod at this level. </p>
</blockquote>
<h4 class="doxsection"><a class="anchor" id="autotoc_md7854"></a>
Gold</h4>
<table class="doxtable">
<tr>
<td align="center"><img src="https://avatars.githubusercontent.com/u/80861386?s=200&amp;v=4" alt="Cerbos" height="45px;" class="inline"/> <br  />
 <a href="https://cerbos.dev/" target="_blank">Cerbos</a> </td><td align="center"><img src="https://avatars.githubusercontent.com/u/301879?s=200&amp;v=4" alt="Scalar.com logo" height="45px;" class="inline"/> <br  />
 <a href="https://scalar.com/" target="_blank">Scalar</a> </td><td align="center"><img src="https://avatars.githubusercontent.com/u/91446104?s=200&amp;v=4" alt="Speakeasy API" height="45px;" class="inline"/> <br  />
 <a href="https://speakeasyapi.dev/" target="_blank">Speakeasy</a> </td><td align="center"><img src="https://avatars0.githubusercontent.com/u/15068039?s=200&amp;v=4" alt="Deletype logo" height="45px;" class="inline"/> <br  />
 <a href="https://deletype.com" target="_blank">Deletype</a> </td><td align="center"><img src="https://avatars.githubusercontent.com/u/95297378?s=200&amp;v=4" alt="Trigger.dev logo" height="45px;" class="inline"/> <br  />
 <a href="https://trigger.dev" target="_blank">Trigger.dev</a> </td></tr>
<tr>
<td align="center"><img src="https://avatars.githubusercontent.com/u/125754?s=200&amp;v=4" alt="Transloadit logo" height="45px;" class="inline"/> <br  />
 <a href="https://transloadit.com/?utm_source=zod&amp;utm_medium=refe
    rral&amp;utm_campaign=sponsorship&amp;utm_content=github" target="_blank">Transloadit</a> </td><td align="center"><img src="https://avatars.githubusercontent.com/u/107880645?s=200&amp;v=4" alt="Infisical logo" height="45px;" class="inline"/> <br  />
 <a href="https://infisical.com" target="_blank">Infisical</a> </td><td align="center"><img src="https://avatars.githubusercontent.com/u/91036480?s=200&amp;v=4" alt="Whop logo" height="45px;" class="inline"/> <br  />
 <a href="https://whop.com/" target="_blank">Whop</a> </td><td align="center"><img src="https://avatars.githubusercontent.com/u/36402888?s=200&amp;v=4" alt="CryptoJobsList logo" height="45px;" class="inline"/> <br  />
 <a href="https://cryptojobslist.com/" target="_blank">CryptoJobsList</a> </td><td align="center"><img src="https://avatars.githubusercontent.com/u/70170949?s=200&amp;v=4" alt="Plain logo" height="45px;" class="inline"/> <br  />
 <a href="https://plain.com/" target="_blank">Plain.</a> </td></tr>
<tr>
<td align="center"><img src="https://avatars.githubusercontent.com/u/78935958?s=200&amp;v=4" alt="Inngest logo" height="45px;" class="inline"/> <br  />
 <a href="https://inngest.com/" target="_blank">Inngest</a> </td><td align="center"><img src="https://avatars.githubusercontent.com/u/13880908?s=200&amp;v=4" alt="Storyblok CMS" height="45px;" class="inline"/> <br  />
 <a href="https://storyblok.com/" target="_blank">Storyblok</a> </td><td align="center"><img src="https://avatars.githubusercontent.com/u/16199997?s=200&amp;v=4" alt="Mux logo" height="45px;" class="inline"/> <br  />
 <a href="https://mux.link/zod" target="_blank">Mux</a> </td><td align="center"><img src="https://avatars.githubusercontent.com/u/180984?v=4" alt="@emreb" height="45px;" class="inline"/> <br  />
 <a href="https://github.com/emreb" target="_blank"><code>@emreb</code></a> </td></tr>
</table>
<h4 class="doxsection"><a class="anchor" id="autotoc_md7855"></a>
Silver</h4>
<table class="doxtable">
<tr>
<td align="center"><a href="https://www.numeric.io"><img src="https://i.imgur.com/kTiLtZt.png" alt="Numeric logo" height="40px;" class="inline"/> </a> </td><td><a href="https://marcatopartners.com"><img src="https://avatars.githubusercontent.com/u/84106192?s=200&amp;v=4" alt="Marcato Partners" height="40px;" class="inline"/> </a> </td><td><a href="https://interval.com"><img src="https://avatars.githubusercontent.com/u/67802063?s=200&amp;v=4" alt="" height="40px;" class="inline"/> </a> </td><td><a href="https://seasoned.cc"><img src="https://avatars.githubusercontent.com/u/33913103?s=200&amp;v=4" alt="" height="40px;" class="inline"/> </a> </td><td><a href="https://www.bamboocreative.nz/"><img src="https://avatars.githubusercontent.com/u/41406870?v=4" alt="Bamboo Creative logo" height="40px;" class="inline"/> </a> </td></tr>
</table>
<h4 class="doxsection"><a class="anchor" id="autotoc_md7856"></a>
Bronze</h4>
<table class="doxtable">
<tr>
<td>Brandon Bayer</td><td>Ji≈ô√≠ Brabec</td><td>Alex Johansson</td><td>Fungible Systems</td></tr>
<tr>
<td>Adaptable</td><td>Avana Wallet</td><td>Jason Lengstorf</td><td>Global Illumination, Inc.</td></tr>
<tr>
<td>MasterBorn</td><td>Ryan Palmer</td><td>Michael Sweeney</td><td>Nextbase</td></tr>
<tr>
<td>Remotion</td><td>Connor Sinnott</td><td>Mohammad-Ali A'r√¢bi</td><td>Supatool</td></tr>
<tr>
<td>Social Crow</td></tr>
</table>
<h3 class="doxsection"><a class="anchor" id="autotoc_md7857"></a>
Ecosystem</h3>
<p>There are a growing number of tools that are built atop or support Zod natively! If you've built a tool or library on top of Zod, tell me about it <a href="https://twitter.com/colinhacks">on Twitter</a> or <a href="https://github.com/colinhacks/zod/discussions">start a Discussion</a>. I'll add it below and tweet it out.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md7858"></a>
Resources</h4>
<ul>
<li><a href="https://www.totaltypescript.com/tutorials/zod">Total TypeScript Zod Tutorial</a> by <a href="https://twitter.com/mattpocockuk">@mattpocockuk</a></li>
<li><a href="https://www.youtube.com/watch?v=rY_XqfSHock">Fixing TypeScript's Blindspot: Runtime Typechecking</a> by <a href="https://twitter.com/jherr">@jherr</a></li>
</ul>
<h4 class="doxsection"><a class="anchor" id="autotoc_md7859"></a>
API libraries</h4>
<ul>
<li><a href="https://github.com/trpc/trpc"><span class="tt">tRPC</span></a>: Build end-to-end typesafe APIs without GraphQL.</li>
<li><a href="https://github.com/anatine/zod-plugins/tree/main/packages/zod-nestjs"><span class="tt">@anatine/zod-nestjs</span></a>: Helper methods for using Zod in a NestJS project.</li>
<li><a href="https://github.com/flock-community/zod-endpoints"><span class="tt">zod-endpoints</span></a>: Contract-first strictly typed endpoints with Zod. OpenAPI compatible.</li>
<li><a href="https://github.com/evertdespiegeleer/zhttp"><span class="tt">zhttp</span></a>: An OpenAPI compatible, strictly typed http library with Zod input and response validation.</li>
<li><a href="https://github.com/SeasonedSoftware/domain-functions/"><span class="tt">domain-functions</span></a>: Decouple your business logic from your framework using composable functions. With first-class type inference from end to end powered by Zod schemas.</li>
<li><a href="https://github.com/ecyrbe/zodios"><span class="tt">@zodios/core</span></a>: A typescript API client with runtime and compile time validation backed by axios and zod.</li>
<li><a href="https://github.com/RobinTail/express-zod-api"><span class="tt">express-zod-api</span></a>: Build Express-based APIs with I/O schema validation and custom middlewares.</li>
<li><a href="https://github.com/sumukhbarve/monoduck/blob/main/src/tapiduck/README.md"><span class="tt">tapiduck</span></a>: End-to-end typesafe JSON APIs with Zod and Express; a bit like tRPC, but simpler.</li>
<li><a href="https://github.com/JakeFenley/koa-zod-router"><span class="tt">koa-zod-router</span></a>: Create typesafe routes in Koa with I/O validation using Zod.</li>
</ul>
<h4 class="doxsection"><a class="anchor" id="autotoc_md7860"></a>
Form integrations</h4>
<ul>
<li><a href="https://github.com/react-hook-form/resolvers#zod"><span class="tt">react-hook-form</span></a>: A first-party Zod resolver for React Hook Form.</li>
<li><a href="https://github.com/causaly/zod-validation-error"><span class="tt">zod-validation-error</span></a>: Generate user-friendly error messages from <span class="tt">ZodError</span>s.</li>
<li><a href="https://github.com/robertLichtnow/zod-formik-adapter"><span class="tt">zod-formik-adapter</span></a>: A community-maintained Formik adapter for Zod.</li>
<li><a href="https://github.com/esamattis/react-zorm"><span class="tt">react-zorm</span></a>: Standalone <span class="tt">&lt;form&gt;</span> generation and validation for React using Zod.</li>
<li><a href="https://github.com/rileytomasek/zodix"><span class="tt">zodix</span></a>: Zod utilities for FormData and URLSearchParams in Remix loaders and actions.</li>
<li><a href="https://conform.guide/api/zod/parseWithZod"><span class="tt">conform</span></a>: A typesafe form validation library for progressive enhancement of HTML forms. Works with Remix and Next.js.</li>
<li><a href="https://github.com/kiliman/remix-params-helper"><span class="tt">remix-params-helper</span></a>: Simplify integration of Zod with standard URLSearchParams and FormData for Remix apps.</li>
<li><a href="https://github.com/glazy/formik-validator-zod"><span class="tt">formik-validator-zod</span></a>: Formik-compliant validator library that simplifies using Zod with Formik.</li>
<li><a href="https://github.com/aiji42/zod-i18n"><span class="tt">zod-i18n-map</span></a>: Useful for translating Zod error messages.</li>
<li><a href="https://github.com/fabian-hiller/modular-forms"><span class="tt">@modular-forms/solid</span></a>: Modular form library for SolidJS that supports Zod for validation.</li>
<li><a href="https://github.com/crutchcorn/houseform/"><span class="tt">houseform</span></a>: A React form library that uses Zod for validation.</li>
<li><a href="https://github.com/ciscoheat/sveltekit-superforms"><span class="tt">sveltekit-superforms</span></a>: Supercharged form library for SvelteKit with Zod validation.</li>
<li><a href="https://github.com/MonoidDev/mobx-zod-form"><span class="tt">mobx-zod-form</span></a>: Data-first form builder based on MobX &amp; Zod.</li>
<li><a href="https://github.com/logaretm/vee-validate/tree/main/packages/zod"><span class="tt">@vee-validate/zod</span></a>: Form library for Vue.js with Zod schema validation.</li>
</ul>
<h4 class="doxsection"><a class="anchor" id="autotoc_md7861"></a>
Zod to X</h4>
<ul>
<li><a href="https://github.com/sachinraja/zod-to-ts"><span class="tt">zod-to-ts</span></a>: Generate TypeScript definitions from Zod schemas.</li>
<li><a href="https://github.com/StefanTerdell/zod-to-json-schema"><span class="tt">zod-to-json-schema</span></a>: Convert your Zod schemas into <a href="https://json-schema.org/">JSON Schemas</a>.</li>
<li><a href="https://github.com/anatine/zod-plugins/tree/main/packages/zod-openapi"><span class="tt">@anatine/zod-openapi</span></a>: Converts a Zod schema to an OpenAPI v3.x <span class="tt">SchemaObject</span>.</li>
<li><a href="https://github.com/DavidTimms/zod-fast-check"><span class="tt">zod-fast-check</span></a>: Generate <span class="tt">fast-check</span> arbitraries from Zod schemas.</li>
<li><a href="https://github.com/kbkk/abitia/tree/master/packages/zod-dto"><span class="tt">zod-dto</span></a>: Generate Nest.js DTOs from a Zod schema.</li>
<li><a href="https://github.com/turkerdev/fastify-type-provider-zod"><span class="tt">fastify-type-provider-zod</span></a>: Create Fastify type providers from Zod schemas.</li>
<li><a href="https://github.com/asteasolutions/zod-to-openapi"><span class="tt">zod-to-openapi</span></a>: Generate full OpenAPI (Swagger) docs from Zod, including schemas, endpoints &amp; parameters.</li>
<li><a href="https://github.com/incetarik/nestjs-graphql-zod"><span class="tt">nestjs-graphql-zod</span></a>: Generates NestJS GraphQL model classes from Zod schemas. Provides GraphQL method decorators working with Zod schemas.</li>
<li><a href="https://github.com/samchungy/zod-openapi"><span class="tt">zod-openapi</span></a>: Create full OpenAPI v3.x documentation from Zod schemas.</li>
<li><a href="https://github.com/samchungy/fastify-zod-openapi"><span class="tt">fastify-zod-openapi</span></a>: Fastify type provider, validation, serialization and @fastify/swagger support for Zod schemas.</li>
<li><a href="https://typeschema.com/"><span class="tt">typeschema</span></a>: Universal adapter for schema validation.</li>
</ul>
<h4 class="doxsection"><a class="anchor" id="autotoc_md7862"></a>
X to Zod</h4>
<ul>
<li><a href="https://github.com/fabien0102/ts-to-zod"><span class="tt">ts-to-zod</span></a>: Convert TypeScript definitions into Zod schemas.</li>
<li><a href="https://github.com/johngeorgewright/runtyping/tree/master/packages/zod"><span class="tt">@runtyping/zod</span></a>: Generate Zod from static types &amp; JSON schema.</li>
<li><a href="https://github.com/StefanTerdell/json-schema-to-zod"><span class="tt">json-schema-to-zod</span></a>: Convert your <a href="https://json-schema.org/">JSON Schemas</a> into Zod schemas. <a href="https://StefanTerdell.github.io/json-schema-to-zod-react/">Live demo</a>.</li>
<li><a href="https://github.com/rsinohara/json-to-zod"><span class="tt">json-to-zod</span></a>: Convert JSON objects into Zod schemas. <a href="https://rsinohara.github.io/json-to-zod-react/">Live demo</a>.</li>
<li><a href="https://github.com/Code-Hex/graphql-codegen-typescript-validation-schema"><span class="tt">graphql-codegen-typescript-validation-schema</span></a>: GraphQL Code Generator plugin to generate form validation schema from your GraphQL schema.</li>
<li><a href="https://github.com/CarterGrimmeisen/zod-prisma"><span class="tt">zod-prisma</span></a>: Generate Zod schemas from your Prisma schema.</li>
<li><a href="https://github.com/Southclaws/supervillain"><span class="tt">Supervillain</span></a>: Generate Zod schemas from your Go structs.</li>
<li><a href="https://github.com/omar-dulaimi/prisma-zod-generator"><span class="tt">prisma-zod-generator</span></a>: Emit Zod schemas from your Prisma schema.</li>
<li><a href="https://github.com/omar-dulaimi/prisma-trpc-generator"><span class="tt">prisma-trpc-generator</span></a>: Emit fully implemented tRPC routers and their validation schemas using Zod.</li>
<li><a href="https://github.com/chrishoermann/zod-prisma-types"><span class="tt">zod-prisma-types</span></a> Create Zod types from your Prisma models.</li>
<li><a href="https://app.quicktype.io/"><span class="tt">quicktype</span></a>: Convert JSON objects and JSON schemas into Zod schemas.</li>
<li><a href="https://github.com/saiichihashimoto/sanity-typed/tree/main/packages/zod"><span class="tt">@sanity-typed/zod</span></a>: Generate Zod Schemas from <a href="https://www.sanity.io/docs/schema-types">Sanity Schemas</a>.</li>
<li><a href="https://github.com/ivangreene/java-to-zod"><span class="tt">java-to-zod</span></a>: Convert POJOs to Zod schemas</li>
<li><a href="https://github.com/anymaniax/orval"><span class="tt">Orval</span></a>: Generate Zod schemas from OpenAPI schemas</li>
</ul>
<h4 class="doxsection"><a class="anchor" id="autotoc_md7863"></a>
Mocking</h4>
<ul>
<li><a href="https://github.com/anatine/zod-plugins/tree/main/packages/zod-mock"><span class="tt">@anatine/zod-mock</span></a>: Generate mock data from a Zod schema. Powered by <a href="https://github.com/faker-js/faker">faker.js</a>.</li>
<li><a href="https://github.com/dipasqualew/zod-mocking"><span class="tt">zod-mocking</span></a>: Generate mock data from your Zod schemas.</li>
<li><a href="https://github.com/timdeschryver/zod-fixture"><span class="tt">zod-fixture</span></a>: Use your zod schemas to automate the generation of non-relevant test fixtures in a deterministic way.</li>
<li><a href="https://zocker.sigrist.dev"><span class="tt">zocker</span></a>: Generate plausible mock-data from your schemas.</li>
<li><a href="https://github.com/ItMaga/zodock"><span class="tt">zodock</span></a> Generate mock data based on Zod schemas.</li>
</ul>
<h4 class="doxsection"><a class="anchor" id="autotoc_md7864"></a>
Powered by Zod</h4>
<ul>
<li><a href="https://github.com/JacobWeisenburger/freerstore"><span class="tt">freerstore</span></a>: Firestore cost optimizer.</li>
<li><a href="https://github.com/gajus/slonik/tree/gajus/add-zod-validation-backwards-compatible#runtime-validation-and-static-type-inference"><span class="tt">slonik</span></a>: Node.js Postgres client with strong Zod integration.</li>
<li><a href="https://github.com/mdbetancourt/soly"><span class="tt">soly</span></a>: Create CLI applications with zod.</li>
<li><a href="https://github.com/vadimdemedes/pastel"><span class="tt">pastel</span></a>: Create CLI applications with react, zod, and ink.</li>
<li><a href="https://github.com/sidwebworks/zod-xlsx"><span class="tt">zod-xlsx</span></a>: A xlsx based resource validator using Zod schemas.</li>
<li><a href="https://github.com/lostfictions/znv"><span class="tt">znv</span></a>: Type-safe environment parsing and validation for Node.js with Zod schemas.</li>
<li><a href="https://github.com/alexmarqs/zod-config"><span class="tt">zod-config</span></a>: Load configurations across multiple sources with flexible adapters, ensuring type safety with Zod.</li>
</ul>
<h4 class="doxsection"><a class="anchor" id="autotoc_md7865"></a>
Utilities for Zod</h4>
<ul>
<li><a href="https://github.com/JacobWeisenburger/zod_utilz"><span class="tt">zod_utilz</span></a>: Framework agnostic utilities for Zod.</li>
<li><a href="https://github.com/marilari88/zod-playground"><span class="tt">zod-playground</span></a>: A tool for learning and testing Zod schema validation functionalities. <a href="https://zod-playground.vercel.app/">Link</a>.</li>
<li><a href="https://github.com/nereumelo/zod-sandbox"><span class="tt">zod-sandbox</span></a>: Controlled environment for testing zod schemas. <a href="https://zod-sandbox.vercel.app/">Live demo</a>.</li>
<li><a href="https://github.com/schalkventer/zod-dev"><span class="tt">zod-dev</span></a>: Conditionally disables Zod runtime parsing in production.</li>
<li><a href="https://github.com/duplojs/duplojs-zod-accelerator"><span class="tt">zod-accelerator</span></a>: Accelerates Zod's throughput up to ~100x.</li>
</ul>
<h2 class="doxsection"><a class="anchor" id="autotoc_md7866"></a>
Installation</h2>
<h3 class="doxsection"><a class="anchor" id="autotoc_md7867"></a>
Requirements</h3>
<ul>
<li>TypeScript 4.5+!</li>
<li><p class="startli">You must enable <span class="tt">strict</span> mode in your <span class="tt">tsconfig.json</span>. This is a best practice for all TypeScript projects.</p>
<div class="fragment"><div class="line">// tsconfig.json</div>
<div class="line">{</div>
<div class="line">  // ...</div>
<div class="line">  &quot;compilerOptions&quot;: {</div>
<div class="line">    // ...</div>
<div class="line">    &quot;strict&quot;: true</div>
<div class="line">  }</div>
<div class="line">}</div>
</div><!-- fragment --></li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md7868"></a>
From <span class="tt">npm</span> (Node/Bun)</h3>
<div class="fragment"><div class="line">npm install zod       # npm</div>
<div class="line">yarn add zod          # yarn</div>
<div class="line">bun add zod           # bun</div>
<div class="line">pnpm add zod          # pnpm</div>
</div><!-- fragment --><p>Zod also publishes a canary version on every commit. To install the canary:</p>
<div class="fragment"><div class="line">npm install zod@canary       # npm</div>
<div class="line">yarn add zod@canary          # yarn</div>
<div class="line">bun add zod@canary           # bun</div>
<div class="line">pnpm add zod@canary          # pnpm</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md7869"></a>
From <span class="tt">deno.land/x</span> (Deno)</h3>
<p>Unlike Node, Deno relies on direct URL imports instead of a package manager like NPM. Zod is available on <a href="https://deno.land/x">deno.land/x</a>. The latest version can be imported like so:</p>
<div class="fragment"><div class="line">import { z } from &quot;https://deno.land/x/zod/mod.ts&quot;;</div>
</div><!-- fragment --><p>You can also specify a particular version:</p>
<div class="fragment"><div class="line">import { z } from &quot;https://deno.land/x/zod@v3.16.1/mod.ts&quot;;</div>
</div><!-- fragment --><blockquote class="doxtable">
<p>The rest of this README assumes you are using npm and importing directly from the <span class="tt">"zod"</span> package. </p>
</blockquote>
<h2 class="doxsection"><a class="anchor" id="autotoc_md7870"></a>
Basic usage</h2>
<p>Creating a simple string schema</p>
<div class="fragment"><div class="line">import { z } from &quot;zod&quot;;</div>
<div class="line"> </div>
<div class="line">// creating a schema for strings</div>
<div class="line">const mySchema = z.string();</div>
<div class="line"> </div>
<div class="line">// parsing</div>
<div class="line">mySchema.parse(&quot;tuna&quot;); // =&gt; &quot;tuna&quot;</div>
<div class="line">mySchema.parse(12); // =&gt; throws ZodError</div>
<div class="line"> </div>
<div class="line">// &quot;safe&quot; parsing (doesn&#39;t throw error if validation fails)</div>
<div class="line">mySchema.safeParse(&quot;tuna&quot;); // =&gt; { success: true; data: &quot;tuna&quot; }</div>
<div class="line">mySchema.safeParse(12); // =&gt; { success: false; error: ZodError }</div>
</div><!-- fragment --><p>Creating an object schema</p>
<div class="fragment"><div class="line">import { z } from &quot;zod&quot;;</div>
<div class="line"> </div>
<div class="line">const User = z.object({</div>
<div class="line">  username: z.string(),</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">User.parse({ username: &quot;Ludwig&quot; });</div>
<div class="line"> </div>
<div class="line">// extract the inferred type</div>
<div class="line">type User = z.infer&lt;typeof User&gt;;</div>
<div class="line">// { username: string }</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md7871"></a>
Primitives</h2>
<div class="fragment"><div class="line">import { z } from &quot;zod&quot;;</div>
<div class="line"> </div>
<div class="line">// primitive values</div>
<div class="line">z.string();</div>
<div class="line">z.number();</div>
<div class="line">z.bigint();</div>
<div class="line">z.boolean();</div>
<div class="line">z.date();</div>
<div class="line">z.symbol();</div>
<div class="line"> </div>
<div class="line">// empty types</div>
<div class="line">z.undefined();</div>
<div class="line">z.null();</div>
<div class="line">z.void(); // accepts undefined</div>
<div class="line"> </div>
<div class="line">// catch-all types</div>
<div class="line">// allows any value</div>
<div class="line">z.any();</div>
<div class="line">z.unknown();</div>
<div class="line"> </div>
<div class="line">// never type</div>
<div class="line">// allows no values</div>
<div class="line">z.never();</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md7872"></a>
Coercion for primitives</h2>
<p>Zod now provides a more convenient way to coerce primitive values.</p>
<div class="fragment"><div class="line">const schema = z.coerce.string();</div>
<div class="line">schema.parse(&quot;tuna&quot;); // =&gt; &quot;tuna&quot;</div>
<div class="line">schema.parse(12); // =&gt; &quot;12&quot;</div>
</div><!-- fragment --><p>During the parsing step, the input is passed through the <span class="tt">String()</span> function, which is a JavaScript built-in for coercing data into strings.</p>
<div class="fragment"><div class="line">schema.parse(12); // =&gt; &quot;12&quot;</div>
<div class="line">schema.parse(true); // =&gt; &quot;true&quot;</div>
<div class="line">schema.parse(undefined); // =&gt; &quot;undefined&quot;</div>
<div class="line">schema.parse(null); // =&gt; &quot;null&quot;</div>
</div><!-- fragment --><p>The returned schema is a normal <span class="tt">ZodString</span> instance so you can use all string methods.</p>
<div class="fragment"><div class="line">z.coerce.string().email().min(5);</div>
</div><!-- fragment --><p><b>How coercion works</b></p>
<p>All primitive types support coercion. Zod coerces all inputs using the built-in constructors: <span class="tt">String(input)</span>, <span class="tt">Number(input)</span>, <span class="tt">new Date(input)</span>, etc.</p>
<div class="fragment"><div class="line">z.coerce.string(); // String(input)</div>
<div class="line">z.coerce.number(); // Number(input)</div>
<div class="line">z.coerce.boolean(); // Boolean(input)</div>
<div class="line">z.coerce.bigint(); // BigInt(input)</div>
<div class="line">z.coerce.date(); // new Date(input)</div>
</div><!-- fragment --><p><b>Note</b> ‚Äî¬†Boolean coercion with <span class="tt">z.coerce.boolean()</span> may not work how you expect. Any <a href="https://developer.mozilla.org/en-US/docs/Glossary/Truthy">truthy</a> value is coerced to <span class="tt">true</span>, and any <a href="https://developer.mozilla.org/en-US/docs/Glossary/Falsy">falsy</a> value is coerced to <span class="tt">false</span>.</p>
<div class="fragment"><div class="line">const schema = z.coerce.boolean(); // Boolean(input)</div>
<div class="line"> </div>
<div class="line">schema.parse(&quot;tuna&quot;); // =&gt; true</div>
<div class="line">schema.parse(&quot;true&quot;); // =&gt; true</div>
<div class="line">schema.parse(&quot;false&quot;); // =&gt; true</div>
<div class="line">schema.parse(1); // =&gt; true</div>
<div class="line">schema.parse([]); // =&gt; true</div>
<div class="line"> </div>
<div class="line">schema.parse(0); // =&gt; false</div>
<div class="line">schema.parse(&quot;&quot;); // =&gt; false</div>
<div class="line">schema.parse(undefined); // =&gt; false</div>
<div class="line">schema.parse(null); // =&gt; false</div>
</div><!-- fragment --><p>For more control over coercion logic, consider using `z.preprocess` or `z.pipe()`.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md7873"></a>
Literals</h2>
<p>Literal schemas represent a <a href="https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#literal-types">literal type</a>, like <span class="tt">"hello world"</span> or <span class="tt">5</span>.</p>
<div class="fragment"><div class="line">const tuna = z.literal(&quot;tuna&quot;);</div>
<div class="line">const twelve = z.literal(12);</div>
<div class="line">const twobig = z.literal(2n); // bigint literal</div>
<div class="line">const tru = z.literal(true);</div>
<div class="line"> </div>
<div class="line">const terrificSymbol = Symbol(&quot;terrific&quot;);</div>
<div class="line">const terrific = z.literal(terrificSymbol);</div>
<div class="line"> </div>
<div class="line">// retrieve literal value</div>
<div class="line">tuna.value; // &quot;tuna&quot;</div>
</div><!-- fragment --><blockquote class="doxtable">
<p>Currently there is no support for Date literals in Zod. If you have a use case for this feature, please file an issue. </p>
</blockquote>
<h2 class="doxsection"><a class="anchor" id="autotoc_md7874"></a>
Strings</h2>
<p>Zod includes a handful of string-specific validations.</p>
<div class="fragment"><div class="line">// validations</div>
<div class="line">z.string().max(5);</div>
<div class="line">z.string().min(5);</div>
<div class="line">z.string().length(5);</div>
<div class="line">z.string().email();</div>
<div class="line">z.string().url();</div>
<div class="line">z.string().emoji();</div>
<div class="line">z.string().uuid();</div>
<div class="line">z.string().nanoid();</div>
<div class="line">z.string().cuid();</div>
<div class="line">z.string().cuid2();</div>
<div class="line">z.string().ulid();</div>
<div class="line">z.string().regex(regex);</div>
<div class="line">z.string().includes(string);</div>
<div class="line">z.string().startsWith(string);</div>
<div class="line">z.string().endsWith(string);</div>
<div class="line">z.string().datetime(); // ISO 8601; by default only `Z` timezone allowed</div>
<div class="line">z.string().ip(); // defaults to allow both IPv4 and IPv6</div>
<div class="line"> </div>
<div class="line">// transforms</div>
<div class="line">z.string().trim(); // trim whitespace</div>
<div class="line">z.string().toLowerCase(); // toLowerCase</div>
<div class="line">z.string().toUpperCase(); // toUpperCase</div>
<div class="line"> </div>
<div class="line">// added in Zod 3.23</div>
<div class="line">z.string().date(); // ISO date format (YYYY-MM-DD)</div>
<div class="line">z.string().time(); // ISO time format (HH:mm:ss[.SSSSSS])</div>
<div class="line">z.string().duration(); // ISO 8601 duration</div>
<div class="line">z.string().base64();</div>
</div><!-- fragment --><blockquote class="doxtable">
<p>Check out <a href="https://github.com/validatorjs/validator.js">validator.js</a> for a bunch of other useful string validation functions that can be used in conjunction with Refinements. </p>
</blockquote>
<p>You can customize some common error messages when creating a string schema.</p>
<div class="fragment"><div class="line">const name = z.string({</div>
<div class="line">  required_error: &quot;Name is required&quot;,</div>
<div class="line">  invalid_type_error: &quot;Name must be a string&quot;,</div>
<div class="line">});</div>
</div><!-- fragment --><p>When using validation methods, you can pass in an additional argument to provide a custom error message.</p>
<div class="fragment"><div class="line">z.string().min(5, { message: &quot;Must be 5 or more characters long&quot; });</div>
<div class="line">z.string().max(5, { message: &quot;Must be 5 or fewer characters long&quot; });</div>
<div class="line">z.string().length(5, { message: &quot;Must be exactly 5 characters long&quot; });</div>
<div class="line">z.string().email({ message: &quot;Invalid email address&quot; });</div>
<div class="line">z.string().url({ message: &quot;Invalid url&quot; });</div>
<div class="line">z.string().emoji({ message: &quot;Contains non-emoji characters&quot; });</div>
<div class="line">z.string().uuid({ message: &quot;Invalid UUID&quot; });</div>
<div class="line">z.string().includes(&quot;tuna&quot;, { message: &quot;Must include tuna&quot; });</div>
<div class="line">z.string().startsWith(&quot;https://&quot;, { message: &quot;Must provide secure URL&quot; });</div>
<div class="line">z.string().endsWith(&quot;.com&quot;, { message: &quot;Only .com domains allowed&quot; });</div>
<div class="line">z.string().datetime({ message: &quot;Invalid datetime string! Must be UTC.&quot; });</div>
<div class="line">z.string().date({ message: &quot;Invalid date string!&quot; });</div>
<div class="line">z.string().time({ message: &quot;Invalid time string!&quot; });</div>
<div class="line">z.string().ip({ message: &quot;Invalid IP address&quot; });</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md7875"></a>
Datetimes</h3>
<p>As you may have noticed, Zod string includes a few date/time related validations. These validations are regular expression based, so they are not as strict as a full date/time library. However, they are very convenient for validating user input.</p>
<p>The <span class="tt">z.string().datetime()</span> method enforces ISO 8601; default is no timezone offsets and arbitrary sub-second decimal precision.</p>
<div class="fragment"><div class="line">const datetime = z.string().datetime();</div>
<div class="line"> </div>
<div class="line">datetime.parse(&quot;2020-01-01T00:00:00Z&quot;); // pass</div>
<div class="line">datetime.parse(&quot;2020-01-01T00:00:00.123Z&quot;); // pass</div>
<div class="line">datetime.parse(&quot;2020-01-01T00:00:00.123456Z&quot;); // pass (arbitrary precision)</div>
<div class="line">datetime.parse(&quot;2020-01-01T00:00:00+02:00&quot;); // fail (no offsets allowed)</div>
</div><!-- fragment --><p>Timezone offsets can be allowed by setting the <span class="tt">offset</span> option to <span class="tt">true</span>.</p>
<div class="fragment"><div class="line">const datetime = z.string().datetime({ offset: true });</div>
<div class="line"> </div>
<div class="line">datetime.parse(&quot;2020-01-01T00:00:00+02:00&quot;); // pass</div>
<div class="line">datetime.parse(&quot;2020-01-01T00:00:00.123+02:00&quot;); // pass (millis optional)</div>
<div class="line">datetime.parse(&quot;2020-01-01T00:00:00.123+0200&quot;); // pass (millis optional)</div>
<div class="line">datetime.parse(&quot;2020-01-01T00:00:00.123+02&quot;); // pass (only offset hours)</div>
<div class="line">datetime.parse(&quot;2020-01-01T00:00:00Z&quot;); // pass (Z still supported)</div>
</div><!-- fragment --><p>You can additionally constrain the allowable <span class="tt">precision</span>. By default, arbitrary sub-second precision is supported (but optional).</p>
<div class="fragment"><div class="line">const datetime = z.string().datetime({ precision: 3 });</div>
<div class="line"> </div>
<div class="line">datetime.parse(&quot;2020-01-01T00:00:00.123Z&quot;); // pass</div>
<div class="line">datetime.parse(&quot;2020-01-01T00:00:00Z&quot;); // fail</div>
<div class="line">datetime.parse(&quot;2020-01-01T00:00:00.123456Z&quot;); // fail</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md7876"></a>
Dates</h3>
<blockquote class="doxtable">
<p>Added in Zod 3.23 </p>
</blockquote>
<p>The <span class="tt">z.string().date()</span> method validates strings in the format <span class="tt">YYYY-MM-DD</span>.</p>
<div class="fragment"><div class="line">const date = z.string().date();</div>
<div class="line"> </div>
<div class="line">date.parse(&quot;2020-01-01&quot;); // pass</div>
<div class="line">date.parse(&quot;2020-1-1&quot;); // fail</div>
<div class="line">date.parse(&quot;2020-01-32&quot;); // fail</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md7877"></a>
Times</h3>
<blockquote class="doxtable">
<p>Added in Zod 3.23 </p>
</blockquote>
<p>The <span class="tt">z.string().time()</span> method validates strings in the format <span class="tt">HH:MM:SS[.s+]</span>. The second can include arbitrary decimal precision. It does not allow timezone offsets of any kind.</p>
<div class="fragment"><div class="line">const time = z.string().time();</div>
<div class="line"> </div>
<div class="line">time.parse(&quot;00:00:00&quot;); // pass</div>
<div class="line">time.parse(&quot;09:52:31&quot;); // pass</div>
<div class="line">time.parse(&quot;23:59:59.9999999&quot;); // pass (arbitrary precision)</div>
<div class="line"> </div>
<div class="line">time.parse(&quot;00:00:00.123Z&quot;); // fail (no `Z` allowed)</div>
<div class="line">time.parse(&quot;00:00:00.123+02:00&quot;); // fail (no offsets allowed)</div>
</div><!-- fragment --><p>You can set the <span class="tt">precision</span> option to constrain the allowable decimal precision.</p>
<div class="fragment"><div class="line">const time = z.string().time({ precision: 3 });</div>
<div class="line"> </div>
<div class="line">time.parse(&quot;00:00:00.123&quot;); // pass</div>
<div class="line">time.parse(&quot;00:00:00.123456&quot;); // fail</div>
<div class="line">time.parse(&quot;00:00:00&quot;); // fail</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md7878"></a>
IP addresses</h3>
<p>The <span class="tt">z.string().ip()</span> method by default validate IPv4 and IPv6.</p>
<div class="fragment"><div class="line">const ip = z.string().ip();</div>
<div class="line"> </div>
<div class="line">ip.parse(&quot;192.168.1.1&quot;); // pass</div>
<div class="line">ip.parse(&quot;84d5:51a0:9114:1855:4cfa:f2d7:1f12:7003&quot;); // pass</div>
<div class="line">ip.parse(&quot;84d5:51a0:9114:1855:4cfa:f2d7:1f12:192.168.1.1&quot;); // pass</div>
<div class="line"> </div>
<div class="line">ip.parse(&quot;256.1.1.1&quot;); // fail</div>
<div class="line">ip.parse(&quot;84d5:51a0:9114:gggg:4cfa:f2d7:1f12:7003&quot;); // fail</div>
</div><!-- fragment --><p>You can additionally set the IP <span class="tt">version</span>.</p>
<div class="fragment"><div class="line">const ipv4 = z.string().ip({ version: &quot;v4&quot; });</div>
<div class="line">ipv4.parse(&quot;84d5:51a0:9114:1855:4cfa:f2d7:1f12:7003&quot;); // fail</div>
<div class="line"> </div>
<div class="line">const ipv6 = z.string().ip({ version: &quot;v6&quot; });</div>
<div class="line">ipv6.parse(&quot;192.168.1.1&quot;); // fail</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md7879"></a>
Numbers</h2>
<p>You can customize certain error messages when creating a number schema.</p>
<div class="fragment"><div class="line">const age = z.number({</div>
<div class="line">  required_error: &quot;Age is required&quot;,</div>
<div class="line">  invalid_type_error: &quot;Age must be a number&quot;,</div>
<div class="line">});</div>
</div><!-- fragment --><p>Zod includes a handful of number-specific validations.</p>
<div class="fragment"><div class="line">z.number().gt(5);</div>
<div class="line">z.number().gte(5); // alias .min(5)</div>
<div class="line">z.number().lt(5);</div>
<div class="line">z.number().lte(5); // alias .max(5)</div>
<div class="line"> </div>
<div class="line">z.number().int(); // value must be an integer</div>
<div class="line"> </div>
<div class="line">z.number().positive(); //     &gt; 0</div>
<div class="line">z.number().nonnegative(); //  &gt;= 0</div>
<div class="line">z.number().negative(); //     &lt; 0</div>
<div class="line">z.number().nonpositive(); //  &lt;= 0</div>
<div class="line"> </div>
<div class="line">z.number().multipleOf(5); // Evenly divisible by 5. Alias .step(5)</div>
<div class="line"> </div>
<div class="line">z.number().finite(); // value must be finite, not Infinity or -Infinity</div>
<div class="line">z.number().safe(); // value must be between Number.MIN_SAFE_INTEGER and Number.MAX_SAFE_INTEGER</div>
</div><!-- fragment --><p>Optionally, you can pass in a second argument to provide a custom error message.</p>
<div class="fragment"><div class="line">z.number().lte(5, { message: &quot;thisüëèisüëètooüëèbig&quot; });</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md7880"></a>
BigInts</h2>
<p>Zod includes a handful of bigint-specific validations.</p>
<div class="fragment"><div class="line">z.bigint().gt(5n);</div>
<div class="line">z.bigint().gte(5n); // alias `.min(5n)`</div>
<div class="line">z.bigint().lt(5n);</div>
<div class="line">z.bigint().lte(5n); // alias `.max(5n)`</div>
<div class="line"> </div>
<div class="line">z.bigint().positive(); // &gt; 0n</div>
<div class="line">z.bigint().nonnegative(); // &gt;= 0n</div>
<div class="line">z.bigint().negative(); // &lt; 0n</div>
<div class="line">z.bigint().nonpositive(); // &lt;= 0n</div>
<div class="line"> </div>
<div class="line">z.bigint().multipleOf(5n); // Evenly divisible by 5n.</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md7881"></a>
NaNs</h2>
<p>You can customize certain error messages when creating a nan schema.</p>
<div class="fragment"><div class="line">const isNaN = z.nan({</div>
<div class="line">  required_error: &quot;isNaN is required&quot;,</div>
<div class="line">  invalid_type_error: &quot;isNaN must be &#39;not a number&#39;&quot;,</div>
<div class="line">});</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md7882"></a>
Booleans</h2>
<p>You can customize certain error messages when creating a boolean schema.</p>
<div class="fragment"><div class="line">const isActive = z.boolean({</div>
<div class="line">  required_error: &quot;isActive is required&quot;,</div>
<div class="line">  invalid_type_error: &quot;isActive must be a boolean&quot;,</div>
<div class="line">});</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md7883"></a>
Dates</h2>
<p>Use z.date() to validate <span class="tt">Date</span> instances.</p>
<div class="fragment"><div class="line">z.date().safeParse(new Date()); // success: true</div>
<div class="line">z.date().safeParse(&quot;2022-01-12T00:00:00.000Z&quot;); // success: false</div>
</div><!-- fragment --><p>You can customize certain error messages when creating a date schema.</p>
<div class="fragment"><div class="line">const myDateSchema = z.date({</div>
<div class="line">  required_error: &quot;Please select a date and time&quot;,</div>
<div class="line">  invalid_type_error: &quot;That&#39;s not a date!&quot;,</div>
<div class="line">});</div>
</div><!-- fragment --><p>Zod provides a handful of date-specific validations.</p>
<div class="fragment"><div class="line">z.date().min(new Date(&quot;1900-01-01&quot;), { message: &quot;Too old&quot; });</div>
<div class="line">z.date().max(new Date(), { message: &quot;Too young!&quot; });</div>
</div><!-- fragment --><p><b>Coercion to Date</b></p>
<p>Since <a href="https://github.com/colinhacks/zod/releases/tag/v3.20">zod 3.20</a>, use `z.coerce.date()` to pass the input through <span class="tt">new Date(input)</span>.</p>
<div class="fragment"><div class="line">const dateSchema = z.coerce.date();</div>
<div class="line">type DateSchema = z.infer&lt;typeof dateSchema&gt;;</div>
<div class="line">// type DateSchema = Date</div>
<div class="line"> </div>
<div class="line">/* valid dates */</div>
<div class="line">console.log(dateSchema.safeParse(&quot;2023-01-10T00:00:00.000Z&quot;).success); // true</div>
<div class="line">console.log(dateSchema.safeParse(&quot;2023-01-10&quot;).success); // true</div>
<div class="line">console.log(dateSchema.safeParse(&quot;1/10/23&quot;).success); // true</div>
<div class="line">console.log(dateSchema.safeParse(new Date(&quot;1/10/23&quot;)).success); // true</div>
<div class="line"> </div>
<div class="line">/* invalid dates */</div>
<div class="line">console.log(dateSchema.safeParse(&quot;2023-13-10&quot;).success); // false</div>
<div class="line">console.log(dateSchema.safeParse(&quot;0000-00-00&quot;).success); // false</div>
</div><!-- fragment --><p>For older zod versions, use `z.preprocess` like <a href="https://github.com/colinhacks/zod/discussions/879#discussioncomment-2036276">described in this thread</a>.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md7884"></a>
Zod enums</h2>
<div class="fragment"><div class="line">const FishEnum = z.enum([&quot;Salmon&quot;, &quot;Tuna&quot;, &quot;Trout&quot;]);</div>
<div class="line">type FishEnum = z.infer&lt;typeof FishEnum&gt;;</div>
<div class="line">// &#39;Salmon&#39; | &#39;Tuna&#39; | &#39;Trout&#39;</div>
</div><!-- fragment --><p><span class="tt">z.enum</span> is a Zod-native way to declare a schema with a fixed set of allowable <em>string</em> values. Pass the array of values directly into <span class="tt">z.enum()</span>. Alternatively, use <span class="tt">as const</span> to define your enum values as a tuple of strings. See the <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-4.html#const-assertions">const assertion docs</a> for details.</p>
<div class="fragment"><div class="line">const VALUES = [&quot;Salmon&quot;, &quot;Tuna&quot;, &quot;Trout&quot;] as const;</div>
<div class="line">const FishEnum = z.enum(VALUES);</div>
</div><!-- fragment --><p>This is not allowed, since Zod isn't able to infer the exact values of each element.</p>
<div class="fragment"><div class="line">const fish = [&quot;Salmon&quot;, &quot;Tuna&quot;, &quot;Trout&quot;];</div>
<div class="line">const FishEnum = z.enum(fish);</div>
</div><!-- fragment --><p><b><span class="tt">.enum</span></b></p>
<p>To get autocompletion with a Zod enum, use the <span class="tt">.enum</span> property of your schema:</p>
<div class="fragment"><div class="line">FishEnum.enum.Salmon; // =&gt; autocompletes</div>
<div class="line"> </div>
<div class="line">FishEnum.enum;</div>
<div class="line">/*</div>
<div class="line">=&gt; {</div>
<div class="line">  Salmon: &quot;Salmon&quot;,</div>
<div class="line">  Tuna: &quot;Tuna&quot;,</div>
<div class="line">  Trout: &quot;Trout&quot;,</div>
<div class="line">}</div>
<div class="line">*/</div>
</div><!-- fragment --><p>You can also retrieve the list of options as a tuple with the <span class="tt">.options</span> property:</p>
<div class="fragment"><div class="line">FishEnum.options; // [&quot;Salmon&quot;, &quot;Tuna&quot;, &quot;Trout&quot;];</div>
</div><!-- fragment --><p><b><span class="tt">.exclude/.extract()</span></b></p>
<p>You can create subsets of a Zod enum with the <span class="tt">.exclude</span> and <span class="tt">.extract</span> methods.</p>
<div class="fragment"><div class="line">const FishEnum = z.enum([&quot;Salmon&quot;, &quot;Tuna&quot;, &quot;Trout&quot;]);</div>
<div class="line">const SalmonAndTrout = FishEnum.extract([&quot;Salmon&quot;, &quot;Trout&quot;]);</div>
<div class="line">const TunaOnly = FishEnum.exclude([&quot;Salmon&quot;, &quot;Trout&quot;]);</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md7885"></a>
Native enums</h2>
<p>Zod enums are the recommended approach to defining and validating enums. But if you need to validate against an enum from a third-party library (or you don't want to rewrite your existing enums) you can use <span class="tt">z.nativeEnum()</span>.</p>
<p><b>Numeric enums</b></p>
<div class="fragment"><div class="line">enum Fruits {</div>
<div class="line">  Apple,</div>
<div class="line">  Banana,</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">const FruitEnum = z.nativeEnum(Fruits);</div>
<div class="line">type FruitEnum = z.infer&lt;typeof FruitEnum&gt;; // Fruits</div>
<div class="line"> </div>
<div class="line">FruitEnum.parse(Fruits.Apple); // passes</div>
<div class="line">FruitEnum.parse(Fruits.Banana); // passes</div>
<div class="line">FruitEnum.parse(0); // passes</div>
<div class="line">FruitEnum.parse(1); // passes</div>
<div class="line">FruitEnum.parse(3); // fails</div>
</div><!-- fragment --><p><b>String enums</b></p>
<div class="fragment"><div class="line">enum Fruits {</div>
<div class="line">  Apple = &quot;apple&quot;,</div>
<div class="line">  Banana = &quot;banana&quot;,</div>
<div class="line">  Cantaloupe, // you can mix numerical and string enums</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">const FruitEnum = z.nativeEnum(Fruits);</div>
<div class="line">type FruitEnum = z.infer&lt;typeof FruitEnum&gt;; // Fruits</div>
<div class="line"> </div>
<div class="line">FruitEnum.parse(Fruits.Apple); // passes</div>
<div class="line">FruitEnum.parse(Fruits.Cantaloupe); // passes</div>
<div class="line">FruitEnum.parse(&quot;apple&quot;); // passes</div>
<div class="line">FruitEnum.parse(&quot;banana&quot;); // passes</div>
<div class="line">FruitEnum.parse(0); // passes</div>
<div class="line">FruitEnum.parse(&quot;Cantaloupe&quot;); // fails</div>
</div><!-- fragment --><p><b>Const enums</b></p>
<p>The <span class="tt">.nativeEnum()</span> function works for <span class="tt">as const</span> objects as well. ‚ö†Ô∏è <span class="tt">as const</span> requires TypeScript 3.4+!</p>
<div class="fragment"><div class="line">const Fruits = {</div>
<div class="line">  Apple: &quot;apple&quot;,</div>
<div class="line">  Banana: &quot;banana&quot;,</div>
<div class="line">  Cantaloupe: 3,</div>
<div class="line">} as const;</div>
<div class="line"> </div>
<div class="line">const FruitEnum = z.nativeEnum(Fruits);</div>
<div class="line">type FruitEnum = z.infer&lt;typeof FruitEnum&gt;; // &quot;apple&quot; | &quot;banana&quot; | 3</div>
<div class="line"> </div>
<div class="line">FruitEnum.parse(&quot;apple&quot;); // passes</div>
<div class="line">FruitEnum.parse(&quot;banana&quot;); // passes</div>
<div class="line">FruitEnum.parse(3); // passes</div>
<div class="line">FruitEnum.parse(&quot;Cantaloupe&quot;); // fails</div>
</div><!-- fragment --><p>You can access the underlying object with the <span class="tt">.enum</span> property:</p>
<div class="fragment"><div class="line">FruitEnum.enum.Apple; // &quot;apple&quot;</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md7886"></a>
Optionals</h2>
<p>You can make any schema optional with <span class="tt">z.optional()</span>. This wraps the schema in a <span class="tt">ZodOptional</span> instance and returns the result.</p>
<div class="fragment"><div class="line">const schema = z.optional(z.string());</div>
<div class="line"> </div>
<div class="line">schema.parse(undefined); // =&gt; returns undefined</div>
<div class="line">type A = z.infer&lt;typeof schema&gt;; // string | undefined</div>
</div><!-- fragment --><p>For convenience, you can also call the <span class="tt">.optional()</span> method on an existing schema.</p>
<div class="fragment"><div class="line">const user = z.object({</div>
<div class="line">  username: z.string().optional(),</div>
<div class="line">});</div>
<div class="line">type C = z.infer&lt;typeof user&gt;; // { username?: string | undefined };</div>
</div><!-- fragment --><p>You can extract the wrapped schema from a <span class="tt">ZodOptional</span> instance with <span class="tt">.unwrap()</span>.</p>
<div class="fragment"><div class="line">const stringSchema = z.string();</div>
<div class="line">const optionalString = stringSchema.optional();</div>
<div class="line">optionalString.unwrap() === stringSchema; // true</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md7887"></a>
Nullables</h2>
<p>Similarly, you can create nullable types with <span class="tt">z.nullable()</span>.</p>
<div class="fragment"><div class="line">const nullableString = z.nullable(z.string());</div>
<div class="line">nullableString.parse(&quot;asdf&quot;); // =&gt; &quot;asdf&quot;</div>
<div class="line">nullableString.parse(null); // =&gt; null</div>
</div><!-- fragment --><p>Or use the <span class="tt">.nullable()</span> method.</p>
<div class="fragment"><div class="line">const E = z.string().nullable(); // equivalent to nullableString</div>
<div class="line">type E = z.infer&lt;typeof E&gt;; // string | null</div>
</div><!-- fragment --><p>Extract the inner schema with <span class="tt">.unwrap()</span>.</p>
<div class="fragment"><div class="line">const stringSchema = z.string();</div>
<div class="line">const nullableString = stringSchema.nullable();</div>
<div class="line">nullableString.unwrap() === stringSchema; // true</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md7888"></a>
Objects</h2>
<div class="fragment"><div class="line">// all properties are required by default</div>
<div class="line">const Dog = z.object({</div>
<div class="line">  name: z.string(),</div>
<div class="line">  age: z.number(),</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">// extract the inferred type like this</div>
<div class="line">type Dog = z.infer&lt;typeof Dog&gt;;</div>
<div class="line"> </div>
<div class="line">// equivalent to:</div>
<div class="line">type Dog = {</div>
<div class="line">  name: string;</div>
<div class="line">  age: number;</div>
<div class="line">};</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md7889"></a>
<span class="tt">.shape</span></h3>
<p>Use <span class="tt">.shape</span> to access the schemas for a particular key.</p>
<div class="fragment"><div class="line">Dog.shape.name; // =&gt; string schema</div>
<div class="line">Dog.shape.age; // =&gt; number schema</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md7890"></a>
<span class="tt">.keyof</span></h3>
<p>Use <span class="tt">.keyof</span> to create a <span class="tt">ZodEnum</span> schema from the keys of an object schema.</p>
<div class="fragment"><div class="line">const keySchema = Dog.keyof();</div>
<div class="line">keySchema; // ZodEnum&lt;[&quot;name&quot;, &quot;age&quot;]&gt;</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md7891"></a>
<span class="tt">.extend</span></h3>
<p>You can add additional fields to an object schema with the <span class="tt">.extend</span> method.</p>
<div class="fragment"><div class="line">const DogWithBreed = Dog.extend({</div>
<div class="line">  breed: z.string(),</div>
<div class="line">});</div>
</div><!-- fragment --><p>You can use <span class="tt">.extend</span> to overwrite fields! Be careful with this power!</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md7892"></a>
<span class="tt">.merge</span></h3>
<p>Equivalent to <span class="tt">A.extend(B.shape)</span>.</p>
<div class="fragment"><div class="line">const BaseTeacher = z.object({ students: z.array(z.string()) });</div>
<div class="line">const HasID = z.object({ id: z.string() });</div>
<div class="line"> </div>
<div class="line">const Teacher = BaseTeacher.merge(HasID);</div>
<div class="line">type Teacher = z.infer&lt;typeof Teacher&gt;; // =&gt; { students: string[], id: string }</div>
</div><!-- fragment --><blockquote class="doxtable">
<p>If the two schemas share keys, the properties of B overrides the property of A. The returned schema also inherits the "unknownKeys" policy (strip/strict/passthrough) and the catchall schema of B. </p>
</blockquote>
<h3 class="doxsection"><a class="anchor" id="autotoc_md7893"></a>
<span class="tt">.pick/.omit</span></h3>
<p>Inspired by TypeScript's built-in <span class="tt">Pick</span> and <span class="tt">Omit</span> utility types, all Zod object schemas have <span class="tt">.pick</span> and <span class="tt">.omit</span> methods that return a modified version. Consider this Recipe schema:</p>
<div class="fragment"><div class="line">const Recipe = z.object({</div>
<div class="line">  id: z.string(),</div>
<div class="line">  name: z.string(),</div>
<div class="line">  ingredients: z.array(z.string()),</div>
<div class="line">});</div>
</div><!-- fragment --><p>To only keep certain keys, use <span class="tt">.pick</span> .</p>
<div class="fragment"><div class="line">const JustTheName = Recipe.pick({ name: true });</div>
<div class="line">type JustTheName = z.infer&lt;typeof JustTheName&gt;;</div>
<div class="line">// =&gt; { name: string }</div>
</div><!-- fragment --><p>To remove certain keys, use <span class="tt">.omit</span> .</p>
<div class="fragment"><div class="line">const NoIDRecipe = Recipe.omit({ id: true });</div>
<div class="line"> </div>
<div class="line">type NoIDRecipe = z.infer&lt;typeof NoIDRecipe&gt;;</div>
<div class="line">// =&gt; { name: string, ingredients: string[] }</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md7894"></a>
<span class="tt">.partial</span></h3>
<p>Inspired by the built-in TypeScript utility type <a href="https://www.typescriptlang.org/docs/handbook/utility-types.html#partialtype">Partial</a>, the <span class="tt">.partial</span> method makes all properties optional.</p>
<p>Starting from this object:</p>
<div class="fragment"><div class="line">const user = z.object({</div>
<div class="line">  email: z.string(),</div>
<div class="line">  username: z.string(),</div>
<div class="line">});</div>
<div class="line">// { email: string; username: string }</div>
</div><!-- fragment --><p>We can create a partial version:</p>
<div class="fragment"><div class="line">const partialUser = user.partial();</div>
<div class="line">// { email?: string | undefined; username?: string | undefined }</div>
</div><!-- fragment --><p>You can also specify which properties to make optional:</p>
<div class="fragment"><div class="line">const optionalEmail = user.partial({</div>
<div class="line">  email: true,</div>
<div class="line">});</div>
<div class="line">/*</div>
<div class="line">{</div>
<div class="line">  email?: string | undefined;</div>
<div class="line">  username: string</div>
<div class="line">}</div>
<div class="line">*/</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md7895"></a>
<span class="tt">.deepPartial</span></h3>
<p>The <span class="tt">.partial</span> method is shallow ‚Äî it only applies one level deep. There is also a "deep" version:</p>
<div class="fragment"><div class="line">const user = z.object({</div>
<div class="line">  username: z.string(),</div>
<div class="line">  location: z.object({</div>
<div class="line">    latitude: z.number(),</div>
<div class="line">    longitude: z.number(),</div>
<div class="line">  }),</div>
<div class="line">  strings: z.array(z.object({ value: z.string() })),</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">const deepPartialUser = user.deepPartial();</div>
<div class="line"> </div>
<div class="line">/*</div>
<div class="line">{</div>
<div class="line">  username?: string | undefined,</div>
<div class="line">  location?: {</div>
<div class="line">    latitude?: number | undefined;</div>
<div class="line">    longitude?: number | undefined;</div>
<div class="line">  } | undefined,</div>
<div class="line">  strings?: { value?: string}[]</div>
<div class="line">}</div>
<div class="line">*/</div>
</div><!-- fragment --><blockquote class="doxtable">
<p>Important limitation: deep partials only work as expected in hierarchies of objects, arrays, and tuples. </p>
</blockquote>
<h3 class="doxsection"><a class="anchor" id="autotoc_md7896"></a>
<span class="tt">.required</span></h3>
<p>Contrary to the <span class="tt">.partial</span> method, the <span class="tt">.required</span> method makes all properties required.</p>
<p>Starting from this object:</p>
<div class="fragment"><div class="line">const user = z</div>
<div class="line">  .object({</div>
<div class="line">    email: z.string(),</div>
<div class="line">    username: z.string(),</div>
<div class="line">  })</div>
<div class="line">  .partial();</div>
<div class="line">// { email?: string | undefined; username?: string | undefined }</div>
</div><!-- fragment --><p>We can create a required version:</p>
<div class="fragment"><div class="line">const requiredUser = user.required();</div>
<div class="line">// { email: string; username: string }</div>
</div><!-- fragment --><p>You can also specify which properties to make required:</p>
<div class="fragment"><div class="line">const requiredEmail = user.required({</div>
<div class="line">  email: true,</div>
<div class="line">});</div>
<div class="line">/*</div>
<div class="line">{</div>
<div class="line">  email: string;</div>
<div class="line">  username?: string | undefined;</div>
<div class="line">}</div>
<div class="line">*/</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md7897"></a>
<span class="tt">.passthrough</span></h3>
<p>By default Zod object schemas strip out unrecognized keys during parsing.</p>
<div class="fragment"><div class="line">const person = z.object({</div>
<div class="line">  name: z.string(),</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">person.parse({</div>
<div class="line">  name: &quot;bob dylan&quot;,</div>
<div class="line">  extraKey: 61,</div>
<div class="line">});</div>
<div class="line">// =&gt; { name: &quot;bob dylan&quot; }</div>
<div class="line">// extraKey has been stripped</div>
</div><!-- fragment --><p>Instead, if you want to pass through unknown keys, use <span class="tt">.passthrough()</span> .</p>
<div class="fragment"><div class="line">person.passthrough().parse({</div>
<div class="line">  name: &quot;bob dylan&quot;,</div>
<div class="line">  extraKey: 61,</div>
<div class="line">});</div>
<div class="line">// =&gt; { name: &quot;bob dylan&quot;, extraKey: 61 }</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md7898"></a>
<span class="tt">.strict</span></h3>
<p>By default Zod object schemas strip out unrecognized keys during parsing. You can <em>disallow</em> unknown keys with <span class="tt">.strict()</span> . If there are any unknown keys in the input, Zod will throw an error.</p>
<div class="fragment"><div class="line">const person = z</div>
<div class="line">  .object({</div>
<div class="line">    name: z.string(),</div>
<div class="line">  })</div>
<div class="line">  .strict();</div>
<div class="line"> </div>
<div class="line">person.parse({</div>
<div class="line">  name: &quot;bob dylan&quot;,</div>
<div class="line">  extraKey: 61,</div>
<div class="line">});</div>
<div class="line">// =&gt; throws ZodError</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md7899"></a>
<span class="tt">.strip</span></h3>
<p>You can use the <span class="tt">.strip</span> method to reset an object schema to the default behavior (stripping unrecognized keys).</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md7900"></a>
<span class="tt">.catchall</span></h3>
<p>You can pass a "catchall" schema into an object schema. All unknown keys will be validated against it.</p>
<div class="fragment"><div class="line">const person = z</div>
<div class="line">  .object({</div>
<div class="line">    name: z.string(),</div>
<div class="line">  })</div>
<div class="line">  .catchall(z.number());</div>
<div class="line"> </div>
<div class="line">person.parse({</div>
<div class="line">  name: &quot;bob dylan&quot;,</div>
<div class="line">  validExtraKey: 61, // works fine</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">person.parse({</div>
<div class="line">  name: &quot;bob dylan&quot;,</div>
<div class="line">  validExtraKey: false, // fails</div>
<div class="line">});</div>
<div class="line">// =&gt; throws ZodError</div>
</div><!-- fragment --><p>Using <span class="tt">.catchall()</span> obviates <span class="tt">.passthrough()</span> , <span class="tt">.strip()</span> , or <span class="tt">.strict()</span>. All keys are now considered "known".</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md7901"></a>
Arrays</h2>
<div class="fragment"><div class="line">const stringArray = z.array(z.string());</div>
<div class="line"> </div>
<div class="line">// equivalent</div>
<div class="line">const stringArray = z.string().array();</div>
</div><!-- fragment --><p>Be careful with the <span class="tt">.array()</span> method. It returns a new <span class="tt">ZodArray</span> instance. This means the <em>order</em> in which you call methods matters. For instance:</p>
<div class="fragment"><div class="line">z.string().optional().array(); // (string | undefined)[]</div>
<div class="line">z.string().array().optional(); // string[] | undefined</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md7902"></a>
<span class="tt">.element</span></h3>
<p>Use <span class="tt">.element</span> to access the schema for an element of the array.</p>
<div class="fragment"><div class="line">stringArray.element; // =&gt; string schema</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md7903"></a>
<span class="tt">.nonempty</span></h3>
<p>If you want to ensure that an array contains at least one element, use <span class="tt">.nonempty()</span>.</p>
<div class="fragment"><div class="line">const nonEmptyStrings = z.string().array().nonempty();</div>
<div class="line">// the inferred type is now</div>
<div class="line">// [string, ...string[]]</div>
<div class="line"> </div>
<div class="line">nonEmptyStrings.parse([]); // throws: &quot;Array cannot be empty&quot;</div>
<div class="line">nonEmptyStrings.parse([&quot;Ariana Grande&quot;]); // passes</div>
</div><!-- fragment --><p>You can optionally specify a custom error message:</p>
<div class="fragment"><div class="line">// optional custom error message</div>
<div class="line">const nonEmptyStrings = z.string().array().nonempty({</div>
<div class="line">  message: &quot;Can&#39;t be empty!&quot;,</div>
<div class="line">});</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md7904"></a>
<span class="tt">.min/.max/.length</span></h3>
<div class="fragment"><div class="line">z.string().array().min(5); // must contain 5 or more items</div>
<div class="line">z.string().array().max(5); // must contain 5 or fewer items</div>
<div class="line">z.string().array().length(5); // must contain 5 items exactly</div>
</div><!-- fragment --><p>Unlike <span class="tt">.nonempty()</span> these methods do not change the inferred type.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md7905"></a>
Tuples</h2>
<p>Unlike arrays, tuples have a fixed number of elements and each element can have a different type.</p>
<div class="fragment"><div class="line">const athleteSchema = z.tuple([</div>
<div class="line">  z.string(), // name</div>
<div class="line">  z.number(), // jersey number</div>
<div class="line">  z.object({</div>
<div class="line">    pointsScored: z.number(),</div>
<div class="line">  }), // statistics</div>
<div class="line">]);</div>
<div class="line"> </div>
<div class="line">type Athlete = z.infer&lt;typeof athleteSchema&gt;;</div>
<div class="line">// type Athlete = [string, number, { pointsScored: number }]</div>
</div><!-- fragment --><p>A variadic ("rest") argument can be added with the <span class="tt">.rest</span> method.</p>
<div class="fragment"><div class="line">const variadicTuple = z.tuple([z.string()]).rest(z.number());</div>
<div class="line">const result = variadicTuple.parse([&quot;hello&quot;, 1, 2, 3]);</div>
<div class="line">// =&gt; [string, ...number[]];</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md7906"></a>
Unions</h2>
<p>Zod includes a built-in <span class="tt">z.union</span> method for composing "OR" types.</p>
<div class="fragment"><div class="line">const stringOrNumber = z.union([z.string(), z.number()]);</div>
<div class="line"> </div>
<div class="line">stringOrNumber.parse(&quot;foo&quot;); // passes</div>
<div class="line">stringOrNumber.parse(14); // passes</div>
</div><!-- fragment --><p>Zod will test the input against each of the "options" in order and return the first value that validates successfully.</p>
<p>For convenience, you can also use the `.or` method:</p>
<div class="fragment"><div class="line">const stringOrNumber = z.string().or(z.number());</div>
</div><!-- fragment --><p><b>Optional string validation:</b></p>
<p>To validate an optional form input, you can union the desired string validation with an empty string literal.</p>
<p>This example validates an input that is optional but needs to contain a valid URL:</p>
<div class="fragment"><div class="line">const optionalUrl = z.union([z.string().url().nullish(), z.literal(&quot;&quot;)]);</div>
<div class="line"> </div>
<div class="line">console.log(optionalUrl.safeParse(undefined).success); // true</div>
<div class="line">console.log(optionalUrl.safeParse(null).success); // true</div>
<div class="line">console.log(optionalUrl.safeParse(&quot;&quot;).success); // true</div>
<div class="line">console.log(optionalUrl.safeParse(&quot;https://zod.dev&quot;).success); // true</div>
<div class="line">console.log(optionalUrl.safeParse(&quot;not a valid url&quot;).success); // false</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md7907"></a>
Discriminated unions</h2>
<p>A discriminated union is a union of object schemas that all share a particular key.</p>
<div class="fragment"><div class="line">type MyUnion =</div>
<div class="line">  | { status: &quot;success&quot;; data: string }</div>
<div class="line">  | { status: &quot;failed&quot;; error: Error };</div>
</div><!-- fragment --><p>Such unions can be represented with the <span class="tt">z.discriminatedUnion</span> method. This enables faster evaluation, because Zod can check the <em>discriminator key</em> (<span class="tt">status</span> in the example above) to determine which schema should be used to parse the input. This makes parsing more efficient and lets Zod report friendlier errors.</p>
<p>With the basic union method, the input is tested against each of the provided "options", and in the case of invalidity, issues for all the "options" are shown in the zod error. On the other hand, the discriminated union allows for selecting just one of the "options", testing against it, and showing only the issues related to this "option".</p>
<div class="fragment"><div class="line">const myUnion = z.discriminatedUnion(&quot;status&quot;, [</div>
<div class="line">  z.object({ status: z.literal(&quot;success&quot;), data: z.string() }),</div>
<div class="line">  z.object({ status: z.literal(&quot;failed&quot;), error: z.instanceof(Error) }),</div>
<div class="line">]);</div>
<div class="line"> </div>
<div class="line">myUnion.parse({ status: &quot;success&quot;, data: &quot;yippie ki yay&quot; });</div>
</div><!-- fragment --><p>You can extract a reference to the array of schemas with the <span class="tt">.options</span> property.</p>
<div class="fragment"><div class="line">myUnion.options; // [ZodObject&lt;...&gt;, ZodObject&lt;...&gt;]</div>
</div><!-- fragment --><p>To merge two or more discriminated unions, use <span class="tt">.options</span> with destructuring.</p>
<div class="fragment"><div class="line">const A = z.discriminatedUnion(&quot;status&quot;, [</div>
<div class="line">  /* options */</div>
<div class="line">]);</div>
<div class="line">const B = z.discriminatedUnion(&quot;status&quot;, [</div>
<div class="line">  /* options */</div>
<div class="line">]);</div>
<div class="line"> </div>
<div class="line">const AB = z.discriminatedUnion(&quot;status&quot;, [...A.options, ...B.options]);</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md7908"></a>
Records</h2>
<p>Record schemas are used to validate types such as <span class="tt">Record&lt;string, number&gt;</span>. This is particularly useful for storing or caching items by ID.</p>
<div class="fragment"><div class="line">const User = z.object({ name: z.string() });</div>
<div class="line"> </div>
<div class="line">const UserStore = z.record(z.string(), User);</div>
<div class="line">type UserStore = z.infer&lt;typeof UserStore&gt;;</div>
<div class="line">// =&gt; Record&lt;string, { name: string }&gt;</div>
</div><!-- fragment --><p>The schema and inferred type can be used like so:</p>
<div class="fragment"><div class="line">const userStore: UserStore = {};</div>
<div class="line"> </div>
<div class="line">userStore[&quot;77d2586b-9e8e-4ecf-8b21-ea7e0530eadd&quot;] = {</div>
<div class="line">  name: &quot;Carlotta&quot;,</div>
<div class="line">}; // passes</div>
<div class="line"> </div>
<div class="line">userStore[&quot;77d2586b-9e8e-4ecf-8b21-ea7e0530eadd&quot;] = {</div>
<div class="line">  whatever: &quot;Ice cream sundae&quot;,</div>
<div class="line">}; // TypeError</div>
</div><!-- fragment --><p><b>A note on numerical keys</b></p>
<p>While <span class="tt">z.record(keyType, valueType)</span> is able to accept numerical key types and TypeScript's built-in Record type is <span class="tt">Record&lt;KeyType, ValueType&gt;</span>, it's hard to represent the TypeScript type <span class="tt">Record&lt;number, any&gt;</span> in Zod.</p>
<p>As it turns out, TypeScript's behavior surrounding <span class="tt">[k: number]</span> is a little unintuitive:</p>
<div class="fragment"><div class="line">const testMap: { [k: number]: string } = {</div>
<div class="line">  1: &quot;one&quot;,</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">for (const key in testMap) {</div>
<div class="line">  console.log(`${key}: ${typeof key}`);</div>
<div class="line">}</div>
<div class="line">// prints: `1: string`</div>
</div><!-- fragment --><p>As you can see, JavaScript automatically casts all object keys to strings under the hood. Since Zod is trying to bridge the gap between static and runtime types, it doesn't make sense to provide a way of creating a record schema with numerical keys, since there's no such thing as a numerical key in runtime JavaScript.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md7909"></a>
Maps</h2>
<div class="fragment"><div class="line">const stringNumberMap = z.map(z.string(), z.number());</div>
<div class="line"> </div>
<div class="line">type StringNumberMap = z.infer&lt;typeof stringNumberMap&gt;;</div>
<div class="line">// type StringNumberMap = Map&lt;string, number&gt;</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md7910"></a>
Sets</h2>
<div class="fragment"><div class="line">const numberSet = z.set(z.number());</div>
<div class="line">type NumberSet = z.infer&lt;typeof numberSet&gt;;</div>
<div class="line">// type NumberSet = Set&lt;number&gt;</div>
</div><!-- fragment --><p>Set schemas can be further constrained with the following utility methods.</p>
<div class="fragment"><div class="line">z.set(z.string()).nonempty(); // must contain at least one item</div>
<div class="line">z.set(z.string()).min(5); // must contain 5 or more items</div>
<div class="line">z.set(z.string()).max(5); // must contain 5 or fewer items</div>
<div class="line">z.set(z.string()).size(5); // must contain 5 items exactly</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md7911"></a>
Intersections</h2>
<p>Intersections are useful for creating "logical AND" types. This is useful for intersecting two object types.</p>
<div class="fragment"><div class="line">const Person = z.object({</div>
<div class="line">  name: z.string(),</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">const Employee = z.object({</div>
<div class="line">  role: z.string(),</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">const EmployedPerson = z.intersection(Person, Employee);</div>
<div class="line"> </div>
<div class="line">// equivalent to:</div>
<div class="line">const EmployedPerson = Person.and(Employee);</div>
</div><!-- fragment --><p>Though in many cases, it is recommended to use <span class="tt">A.merge(B)</span> to merge two objects. The <span class="tt">.merge</span> method returns a new <span class="tt">ZodObject</span> instance, whereas <span class="tt">A.and(B)</span> returns a less useful <span class="tt">ZodIntersection</span> instance that lacks common object methods like <span class="tt">pick</span> and <span class="tt">omit</span>.</p>
<div class="fragment"><div class="line">const a = z.union([z.number(), z.string()]);</div>
<div class="line">const b = z.union([z.number(), z.boolean()]);</div>
<div class="line">const c = z.intersection(a, b);</div>
<div class="line"> </div>
<div class="line">type c = z.infer&lt;typeof c&gt;; // =&gt; number</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md7912"></a>
Recursive types</h2>
<p>You can define a recursive schema in Zod, but because of a limitation of TypeScript, their type can't be statically inferred. Instead you'll need to define the type definition manually, and provide it to Zod as a "type hint".</p>
<div class="fragment"><div class="line">const baseCategorySchema = z.object({</div>
<div class="line">  name: z.string(),</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">type Category = z.infer&lt;typeof baseCategorySchema&gt; &amp; {</div>
<div class="line">  subcategories: Category[];</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">const categorySchema: z.ZodType&lt;Category&gt; = baseCategorySchema.extend({</div>
<div class="line">  subcategories: z.lazy(() =&gt; categorySchema.array()),</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">categorySchema.parse({</div>
<div class="line">  name: &quot;People&quot;,</div>
<div class="line">  subcategories: [</div>
<div class="line">    {</div>
<div class="line">      name: &quot;Politicians&quot;,</div>
<div class="line">      subcategories: [</div>
<div class="line">        {</div>
<div class="line">          name: &quot;Presidents&quot;,</div>
<div class="line">          subcategories: [],</div>
<div class="line">        },</div>
<div class="line">      ],</div>
<div class="line">    },</div>
<div class="line">  ],</div>
<div class="line">}); // passes</div>
</div><!-- fragment --><p>Thanks to <a href="https://github.com/crasite">crasite</a> for this example.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md7913"></a>
ZodType with ZodEffects</h3>
<p>When using <span class="tt">z.ZodType</span> with <span class="tt">z.ZodEffects</span> ( <a href="https://github.com/colinhacks/zod#refine"><span class="tt">.refine</span></a>, <a href="https://github.com/colinhacks/zod#transform"><span class="tt">.transform</span></a>, <a href="https://github.com/colinhacks/zod#preprocess"><span class="tt">preprocess</span></a>, etc... ), you will need to define the input and output types of the schema. <span class="tt">z.ZodType&lt;Output, z.ZodTypeDef, Input&gt;</span></p>
<div class="fragment"><div class="line">const isValidId = (id: string): id is `${string}/${string}` =&gt;</div>
<div class="line">  id.split(&quot;/&quot;).length === 2;</div>
<div class="line"> </div>
<div class="line">const baseSchema = z.object({</div>
<div class="line">  id: z.string().refine(isValidId),</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">type Input = z.input&lt;typeof baseSchema&gt; &amp; {</div>
<div class="line">  children: Input[];</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">type Output = z.output&lt;typeof baseSchema&gt; &amp; {</div>
<div class="line">  children: Output[];</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line">const schema: z.ZodType&lt;Output, z.ZodTypeDef, Input&gt; = baseSchema.extend({</div>
<div class="line">  children: z.lazy(() =&gt; schema.array()),</div>
<div class="line">});</div>
</div><!-- fragment --><p>Thanks to <a href="https://github.com/marcus13371337">marcus13371337</a> and <a href="https://github.com/JoelBeeldi">JoelBeeldi</a> for this example.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md7914"></a>
JSON type</h3>
<p>If you want to validate any JSON value, you can use the snippet below.</p>
<div class="fragment"><div class="line">const literalSchema = z.union([z.string(), z.number(), z.boolean(), z.null()]);</div>
<div class="line">type Literal = z.infer&lt;typeof literalSchema&gt;;</div>
<div class="line">type Json = Literal | { [key: string]: Json } | Json[];</div>
<div class="line">const jsonSchema: z.ZodType&lt;Json&gt; = z.lazy(() =&gt;</div>
<div class="line">  z.union([literalSchema, z.array(jsonSchema), z.record(jsonSchema)])</div>
<div class="line">);</div>
<div class="line"> </div>
<div class="line">jsonSchema.parse(data);</div>
</div><!-- fragment --><p>Thanks to <a href="https://github.com/ggoodman">ggoodman</a> for suggesting this.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md7915"></a>
Cyclical objects</h3>
<p>Despite supporting recursive schemas, passing cyclical data into Zod will cause an infinite loop in some cases.</p>
<blockquote class="doxtable">
<p>To detect cyclical objects before they cause problems, consider <a href="https://gist.github.com/colinhacks/d35825e505e635df27cc950776c5500b">this approach</a>. </p>
</blockquote>
<h2 class="doxsection"><a class="anchor" id="autotoc_md7916"></a>
Promises</h2>
<div class="fragment"><div class="line">const numberPromise = z.promise(z.number());</div>
</div><!-- fragment --><p>"Parsing" works a little differently with promise schemas. Validation happens in two parts:</p>
<ol type="1">
<li>Zod synchronously checks that the input is an instance of Promise (i.e. an object with <span class="tt">.then</span> and <span class="tt">.catch</span> methods.).</li>
<li>Zod uses <span class="tt">.then</span> to attach an additional validation step onto the existing Promise. You'll have to use <span class="tt">.catch</span> on the returned Promise to handle validation failures.</li>
</ol>
<div class="fragment"><div class="line">numberPromise.parse(&quot;tuna&quot;);</div>
<div class="line">// ZodError: Non-Promise type: string</div>
<div class="line"> </div>
<div class="line">numberPromise.parse(Promise.resolve(&quot;tuna&quot;));</div>
<div class="line">// =&gt; Promise&lt;number&gt;</div>
<div class="line"> </div>
<div class="line">const test = async () =&gt; {</div>
<div class="line">  await numberPromise.parse(Promise.resolve(&quot;tuna&quot;));</div>
<div class="line">  // ZodError: Non-number type: string</div>
<div class="line"> </div>
<div class="line">  await numberPromise.parse(Promise.resolve(3.14));</div>
<div class="line">  // =&gt; 3.14</div>
<div class="line">};</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md7917"></a>
Instanceof</h2>
<p>You can use <span class="tt">z.instanceof</span> to check that the input is an instance of a class. This is useful to validate inputs against classes that are exported from third-party libraries.</p>
<div class="fragment"><div class="line">class Test {</div>
<div class="line">  name: string;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">const TestSchema = z.instanceof(Test);</div>
<div class="line"> </div>
<div class="line">const blob: any = &quot;whatever&quot;;</div>
<div class="line">TestSchema.parse(new Test()); // passes</div>
<div class="line">TestSchema.parse(blob); // throws</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md7918"></a>
Functions</h2>
<p>Zod also lets you define "function schemas". This makes it easy to validate the inputs and outputs of a function without intermixing your validation code and "business logic".</p>
<p>You can create a function schema with <span class="tt">z.function(args, returnType)</span> .</p>
<div class="fragment"><div class="line">const myFunction = z.function();</div>
<div class="line"> </div>
<div class="line">type myFunction = z.infer&lt;typeof myFunction&gt;;</div>
<div class="line">// =&gt; ()=&gt;unknown</div>
</div><!-- fragment --><p>Define inputs and outputs.</p>
<div class="fragment"><div class="line">const myFunction = z</div>
<div class="line">  .function()</div>
<div class="line">  .args(z.string(), z.number()) // accepts an arbitrary number of arguments</div>
<div class="line">  .returns(z.boolean());</div>
<div class="line"> </div>
<div class="line">type myFunction = z.infer&lt;typeof myFunction&gt;;</div>
<div class="line">// =&gt; (arg0: string, arg1: number)=&gt;boolean</div>
</div><!-- fragment --><p>Function schemas have an <span class="tt">.implement()</span> method which accepts a function and returns a new function that automatically validates its inputs and outputs.</p>
<div class="fragment"><div class="line">const trimmedLength = z</div>
<div class="line">  .function()</div>
<div class="line">  .args(z.string()) // accepts an arbitrary number of arguments</div>
<div class="line">  .returns(z.number())</div>
<div class="line">  .implement((x) =&gt; {</div>
<div class="line">    // TypeScript knows x is a string!</div>
<div class="line">    return x.trim().length;</div>
<div class="line">  });</div>
<div class="line"> </div>
<div class="line">trimmedLength(&quot;sandwich&quot;); // =&gt; 8</div>
<div class="line">trimmedLength(&quot; asdf &quot;); // =&gt; 4</div>
</div><!-- fragment --><p>If you only care about validating inputs, just don't call the <span class="tt">.returns()</span> method. The output type will be inferred from the implementation.</p>
<blockquote class="doxtable">
<p>You can use the special <span class="tt">z.void()</span> option if your function doesn't return anything. This will let Zod properly infer the type of void-returning functions. (Void-returning functions actually return undefined.) </p>
</blockquote>
<div class="fragment"><div class="line">const myFunction = z</div>
<div class="line">  .function()</div>
<div class="line">  .args(z.string())</div>
<div class="line">  .implement((arg) =&gt; {</div>
<div class="line">    return [arg.length];</div>
<div class="line">  });</div>
<div class="line"> </div>
<div class="line">myFunction; // (arg: string)=&gt;number[]</div>
</div><!-- fragment --><p>Extract the input and output schemas from a function schema.</p>
<div class="fragment"><div class="line">myFunction.parameters();</div>
<div class="line">// =&gt; ZodTuple&lt;[ZodString, ZodNumber]&gt;</div>
<div class="line"> </div>
<div class="line">myFunction.returnType();</div>
<div class="line">// =&gt; ZodBoolean</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md7919"></a>
Preprocess</h2>
<blockquote class="doxtable">
<p>Zod now supports primitive coercion without the need for <span class="tt">.preprocess()</span>. See the coercion docs for more information. </p>
</blockquote>
<p>Typically Zod operates under a "parse then transform" paradigm. Zod validates the input first, then passes it through a chain of transformation functions. (For more information about transforms, read the .transform docs.)</p>
<p>But sometimes you want to apply some transform to the input <em>before</em> parsing happens. A common use case: type coercion. Zod enables this with the <span class="tt">z.preprocess()</span>.</p>
<div class="fragment"><div class="line">const castToString = z.preprocess((val) =&gt; String(val), z.string());</div>
</div><!-- fragment --><p>This returns a <span class="tt">ZodEffects</span> instance. <span class="tt">ZodEffects</span> is a wrapper class that contains all logic pertaining to preprocessing, refinements, and transforms.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md7920"></a>
Custom schemas</h2>
<p>You can create a Zod schema for any TypeScript type by using <span class="tt">z.custom()</span>. This is useful for creating schemas for types that are not supported by Zod out of the box, such as template string literals.</p>
<div class="fragment"><div class="line">const px = z.custom&lt;`${number}px`&gt;((val) =&gt; {</div>
<div class="line">  return typeof val === &quot;string&quot; ? /^\d+px$/.test(val) : false;</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">type px = z.infer&lt;typeof px&gt;; // `${number}px`</div>
<div class="line"> </div>
<div class="line">px.parse(&quot;42px&quot;); // &quot;42px&quot;</div>
<div class="line">px.parse(&quot;42vw&quot;); // throws;</div>
</div><!-- fragment --><p>If you don't provide a validation function, Zod will allow any value. This can be dangerous!</p>
<div class="fragment"><div class="line">z.custom&lt;{ arg: string }&gt;(); // performs no validation</div>
</div><!-- fragment --><p>You can customize the error message and other options by passing a second argument. This parameter works the same way as the params parameter of `.refine`.</p>
<div class="fragment"><div class="line">z.custom&lt;...&gt;((val) =&gt; ..., &quot;custom error message&quot;);</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md7921"></a>
Schema methods</h2>
<p>All Zod schemas contain certain methods.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md7922"></a>
<span class="tt">.parse</span></h3>
<p><span class="tt">.parse(data: unknown): T</span></p>
<p>Given any Zod schema, you can call its <span class="tt">.parse</span> method to check <span class="tt">data</span> is valid. If it is, a value is returned with full type information! Otherwise, an error is thrown.</p>
<blockquote class="doxtable">
<p>IMPORTANT: The value returned by <span class="tt">.parse</span> is a <em>deep clone</em> of the variable you passed in. </p>
</blockquote>
<div class="fragment"><div class="line">const stringSchema = z.string();</div>
<div class="line"> </div>
<div class="line">stringSchema.parse(&quot;fish&quot;); // =&gt; returns &quot;fish&quot;</div>
<div class="line">stringSchema.parse(12); // throws error</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md7923"></a>
<span class="tt">.parseAsync</span></h3>
<p><span class="tt">.parseAsync(data:unknown): Promise&lt;T&gt;</span></p>
<p>If you use asynchronous refinements or transforms (more on those later), you'll need to use <span class="tt">.parseAsync</span>.</p>
<div class="fragment"><div class="line">const stringSchema = z.string().refine(async (val) =&gt; val.length &lt;= 8);</div>
<div class="line"> </div>
<div class="line">await stringSchema.parseAsync(&quot;hello&quot;); // =&gt; returns &quot;hello&quot;</div>
<div class="line">await stringSchema.parseAsync(&quot;hello world&quot;); // =&gt; throws error</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md7924"></a>
<span class="tt">.safeParse</span></h3>
<p><span class="tt">.safeParse(data:unknown): { success: true; data: T; } | { success: false; error: ZodError; }</span></p>
<p>If you don't want Zod to throw errors when validation fails, use <span class="tt">.safeParse</span>. This method returns an object containing either the successfully parsed data or a ZodError instance containing detailed information about the validation problems.</p>
<div class="fragment"><div class="line">stringSchema.safeParse(12);</div>
<div class="line">// =&gt; { success: false; error: ZodError }</div>
<div class="line"> </div>
<div class="line">stringSchema.safeParse(&quot;billie&quot;);</div>
<div class="line">// =&gt; { success: true; data: &#39;billie&#39; }</div>
</div><!-- fragment --><p>The result is a <em>discriminated union</em>, so you can handle errors very conveniently:</p>
<div class="fragment"><div class="line">const result = stringSchema.safeParse(&quot;billie&quot;);</div>
<div class="line">if (!result.success) {</div>
<div class="line">  // handle error then return</div>
<div class="line">  result.error;</div>
<div class="line">} else {</div>
<div class="line">  // do something</div>
<div class="line">  result.data;</div>
<div class="line">}</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md7925"></a>
<span class="tt">.safeParseAsync</span></h3>
<blockquote class="doxtable">
<p>Alias: <span class="tt">.spa</span> </p>
</blockquote>
<p>An asynchronous version of <span class="tt">safeParse</span>.</p>
<div class="fragment"><div class="line">await stringSchema.safeParseAsync(&quot;billie&quot;);</div>
</div><!-- fragment --><p>For convenience, this has been aliased to <span class="tt">.spa</span>:</p>
<div class="fragment"><div class="line">await stringSchema.spa(&quot;billie&quot;);</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md7926"></a>
<span class="tt">.refine</span></h3>
<p><span class="tt">.refine(validator: (data:T)=&gt;any, params?: RefineParams)</span></p>
<p>Zod lets you provide custom validation logic via <em>refinements</em>. (For advanced features like creating multiple issues and customizing error codes, see `.superRefine`.)</p>
<p>Zod was designed to mirror TypeScript as closely as possible. But there are many so-called "refinement types" you may wish to check for that can't be represented in TypeScript's type system. For instance: checking that a number is an integer or that a string is a valid email address.</p>
<p>For example, you can define a custom validation check on <em>any</em> Zod schema with <span class="tt">.refine</span> :</p>
<div class="fragment"><div class="line">const myString = z.string().refine((val) =&gt; val.length &lt;= 255, {</div>
<div class="line">  message: &quot;String can&#39;t be more than 255 characters&quot;,</div>
<div class="line">});</div>
</div><!-- fragment --><blockquote class="doxtable">
<p>‚ö†Ô∏è Refinement functions should not throw. Instead they should return a falsy value to signal failure. </p>
</blockquote>
<h4 class="doxsection"><a class="anchor" id="autotoc_md7927"></a>
Arguments</h4>
<p>As you can see, <span class="tt">.refine</span> takes two arguments.</p>
<ol type="1">
<li>The first is the validation function. This function takes one input (of type <span class="tt">T</span> ‚Äî the inferred type of the schema) and returns <span class="tt">any</span>. Any truthy value will pass validation. (Prior to zod@1.6.2 the validation function had to return a boolean.)</li>
<li>The second argument accepts some options. You can use this to customize certain error-handling behavior:</li>
</ol>
<div class="fragment"><div class="line">type RefineParams = {</div>
<div class="line">  // override error message</div>
<div class="line">  message?: string;</div>
<div class="line"> </div>
<div class="line">  // appended to error path</div>
<div class="line">  path?: (string | number)[];</div>
<div class="line"> </div>
<div class="line">  // params object you can use to customize message</div>
<div class="line">  // in error map</div>
<div class="line">  params?: object;</div>
<div class="line">};</div>
</div><!-- fragment --><p>For advanced cases, the second argument can also be a function that returns <span class="tt">RefineParams</span>.</p>
<div class="fragment"><div class="line">const longString = z.string().refine(</div>
<div class="line">  (val) =&gt; val.length &gt; 10,</div>
<div class="line">  (val) =&gt; ({ message: `${val} is not more than 10 characters` })</div>
<div class="line">);</div>
</div><!-- fragment --><h4 class="doxsection"><a class="anchor" id="autotoc_md7928"></a>
Customize error path</h4>
<div class="fragment"><div class="line">const passwordForm = z</div>
<div class="line">  .object({</div>
<div class="line">    password: z.string(),</div>
<div class="line">    confirm: z.string(),</div>
<div class="line">  })</div>
<div class="line">  .refine((data) =&gt; data.password === data.confirm, {</div>
<div class="line">    message: &quot;Passwords don&#39;t match&quot;,</div>
<div class="line">    path: [&quot;confirm&quot;], // path of error</div>
<div class="line">  });</div>
<div class="line"> </div>
<div class="line">passwordForm.parse({ password: &quot;asdf&quot;, confirm: &quot;qwer&quot; });</div>
</div><!-- fragment --><p>Because you provided a <span class="tt">path</span> parameter, the resulting error will be:</p>
<div class="fragment"><div class="line">ZodError {</div>
<div class="line">  issues: [{</div>
<div class="line">    &quot;code&quot;: &quot;custom&quot;,</div>
<div class="line">    &quot;path&quot;: [ &quot;confirm&quot; ],</div>
<div class="line">    &quot;message&quot;: &quot;Passwords don&#39;t match&quot;</div>
<div class="line">  }]</div>
<div class="line">}</div>
</div><!-- fragment --><h4 class="doxsection"><a class="anchor" id="autotoc_md7929"></a>
Asynchronous refinements</h4>
<p>Refinements can also be async:</p>
<div class="fragment"><div class="line">const userId = z.string().refine(async (id) =&gt; {</div>
<div class="line">  // verify that ID exists in database</div>
<div class="line">  return true;</div>
<div class="line">});</div>
</div><!-- fragment --><blockquote class="doxtable">
<p>‚ö†Ô∏è If you use async refinements, you must use the <span class="tt">.parseAsync</span> method to parse data! Otherwise Zod will throw an error. </p>
</blockquote>
<h4 class="doxsection"><a class="anchor" id="autotoc_md7930"></a>
Relationship to transforms</h4>
<p>Transforms and refinements can be interleaved:</p>
<div class="fragment"><div class="line">z.string()</div>
<div class="line">  .transform((val) =&gt; val.length)</div>
<div class="line">  .refine((val) =&gt; val &gt; 25);</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md7931"></a>
<span class="tt">.superRefine</span></h3>
<p>The <span class="tt">.refine</span> method is actually syntactic sugar atop a more versatile (and verbose) method called <span class="tt">superRefine</span>. Here's an example:</p>
<div class="fragment"><div class="line">const Strings = z.array(z.string()).superRefine((val, ctx) =&gt; {</div>
<div class="line">  if (val.length &gt; 3) {</div>
<div class="line">    ctx.addIssue({</div>
<div class="line">      code: z.ZodIssueCode.too_big,</div>
<div class="line">      maximum: 3,</div>
<div class="line">      type: &quot;array&quot;,</div>
<div class="line">      inclusive: true,</div>
<div class="line">      message: &quot;Too many items üò°&quot;,</div>
<div class="line">    });</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  if (val.length !== new Set(val).size) {</div>
<div class="line">    ctx.addIssue({</div>
<div class="line">      code: z.ZodIssueCode.custom,</div>
<div class="line">      message: `No duplicates allowed.`,</div>
<div class="line">    });</div>
<div class="line">  }</div>
<div class="line">});</div>
</div><!-- fragment --><p>You can add as many issues as you like. If <span class="tt">ctx.addIssue</span> is <em>not</em> called during the execution of the function, validation passes.</p>
<p>Normally refinements always create issues with a <span class="tt">ZodIssueCode.custom</span> error code, but with <span class="tt">superRefine</span> it's possible to throw issues of any <span class="tt">ZodIssueCode</span>. Each issue code is described in detail in the Error Handling guide: ERROR_HANDLING.md.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md7932"></a>
Abort early</h4>
<p>By default, parsing will continue even after a refinement check fails. For instance, if you chain together multiple refinements, they will all be executed. However, it may be desirable to <em>abort early</em> to prevent later refinements from being executed. To achieve this, pass the <span class="tt">fatal</span> flag to <span class="tt">ctx.addIssue</span> and return <span class="tt">z.NEVER</span>.</p>
<div class="fragment"><div class="line">const schema = z.number().superRefine((val, ctx) =&gt; {</div>
<div class="line">  if (val &lt; 10) {</div>
<div class="line">    ctx.addIssue({</div>
<div class="line">      code: z.ZodIssueCode.custom,</div>
<div class="line">      message: &quot;should be &gt;= 10&quot;,</div>
<div class="line">      fatal: true,</div>
<div class="line">    });</div>
<div class="line"> </div>
<div class="line">    return z.NEVER;</div>
<div class="line">  }</div>
<div class="line"> </div>
<div class="line">  if (val !== 12) {</div>
<div class="line">    ctx.addIssue({</div>
<div class="line">      code: z.ZodIssueCode.custom,</div>
<div class="line">      message: &quot;should be twelve&quot;,</div>
<div class="line">    });</div>
<div class="line">  }</div>
<div class="line">});</div>
</div><!-- fragment --><h4 class="doxsection"><a class="anchor" id="autotoc_md7933"></a>
Type refinements</h4>
<p>If you provide a <a href="https://www.typescriptlang.org/docs/handbook/2/narrowing.html#using-type-predicates">type predicate</a> to <span class="tt">.refine()</span> or <span class="tt">.superRefine()</span>, the resulting type will be narrowed down to your predicate's type. This is useful if you are mixing multiple chained refinements and transformations:</p>
<div class="fragment"><div class="line">const schema = z</div>
<div class="line">  .object({</div>
<div class="line">    first: z.string(),</div>
<div class="line">    second: z.number(),</div>
<div class="line">  })</div>
<div class="line">  .nullable()</div>
<div class="line">  .superRefine((arg, ctx): arg is { first: string; second: number } =&gt; {</div>
<div class="line">    if (!arg) {</div>
<div class="line">      ctx.addIssue({</div>
<div class="line">        code: z.ZodIssueCode.custom, // customize your issue</div>
<div class="line">        message: &quot;object should exist&quot;,</div>
<div class="line">      });</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    return z.NEVER; // The return value is not used, but we need to return something to satisfy the typing</div>
<div class="line">  })</div>
<div class="line">  // here, TS knows that arg is not null</div>
<div class="line">  .refine((arg) =&gt; arg.first === &quot;bob&quot;, &quot;`first` is not `bob`!&quot;);</div>
</div><!-- fragment --><blockquote class="doxtable">
<p>‚ö†Ô∏è You <b>must</b> use <span class="tt">ctx.addIssue()</span> instead of returning a boolean value to indicate whether the validation passes. If <span class="tt">ctx.addIssue</span> is <em>not</em> called during the execution of the function, validation passes. </p>
</blockquote>
<h3 class="doxsection"><a class="anchor" id="autotoc_md7934"></a>
<span class="tt">.transform</span></h3>
<p>To transform data after parsing, use the <span class="tt">transform</span> method.</p>
<div class="fragment"><div class="line">const stringToNumber = z.string().transform((val) =&gt; val.length);</div>
<div class="line"> </div>
<div class="line">stringToNumber.parse(&quot;string&quot;); // =&gt; 6</div>
</div><!-- fragment --><h4 class="doxsection"><a class="anchor" id="autotoc_md7935"></a>
Chaining order</h4>
<p>Note that <span class="tt">stringToNumber</span> above is an instance of the <span class="tt">ZodEffects</span> subclass. It is NOT an instance of <span class="tt">ZodString</span>. If you want to use the built-in methods of <span class="tt">ZodString</span> (e.g. <span class="tt">.email()</span>) you must apply those methods <em>before</em> any transforms.</p>
<div class="fragment"><div class="line">const emailToDomain = z</div>
<div class="line">  .string()</div>
<div class="line">  .email()</div>
<div class="line">  .transform((val) =&gt; val.split(&quot;@&quot;)[1]);</div>
<div class="line"> </div>
<div class="line">emailToDomain.parse(&quot;colinhacks@example.com&quot;); // =&gt; example.com</div>
</div><!-- fragment --><h4 class="doxsection"><a class="anchor" id="autotoc_md7936"></a>
Validating during transform</h4>
<p>The <span class="tt">.transform</span> method can simultaneously validate and transform the value. This is often simpler and less duplicative than chaining <span class="tt">transform</span> and <span class="tt">refine</span>.</p>
<p>As with <span class="tt">.superRefine</span>, the transform function receives a <span class="tt">ctx</span> object with an <span class="tt">addIssue</span> method that can be used to register validation issues.</p>
<div class="fragment"><div class="line">const numberInString = z.string().transform((val, ctx) =&gt; {</div>
<div class="line">  const parsed = parseInt(val);</div>
<div class="line">  if (isNaN(parsed)) {</div>
<div class="line">    ctx.addIssue({</div>
<div class="line">      code: z.ZodIssueCode.custom,</div>
<div class="line">      message: &quot;Not a number&quot;,</div>
<div class="line">    });</div>
<div class="line"> </div>
<div class="line">    // This is a special symbol you can use to</div>
<div class="line">    // return early from the transform function.</div>
<div class="line">    // It has type `never` so it does not affect the</div>
<div class="line">    // inferred return type.</div>
<div class="line">    return z.NEVER;</div>
<div class="line">  }</div>
<div class="line">  return parsed;</div>
<div class="line">});</div>
</div><!-- fragment --><h4 class="doxsection"><a class="anchor" id="autotoc_md7937"></a>
Relationship to refinements</h4>
<p>Transforms and refinements can be interleaved. These will be executed in the order they are declared.</p>
<div class="fragment"><div class="line">const nameToGreeting = z</div>
<div class="line">  .string()</div>
<div class="line">  .transform((val) =&gt; val.toUpperCase())</div>
<div class="line">  .refine((val) =&gt; val.length &gt; 15)</div>
<div class="line">  .transform((val) =&gt; `Hello ${val}`)</div>
<div class="line">  .refine((val) =&gt; val.indexOf(&quot;!&quot;) === -1);</div>
</div><!-- fragment --><h4 class="doxsection"><a class="anchor" id="autotoc_md7938"></a>
Async transforms</h4>
<p>Transforms can also be async.</p>
<div class="fragment"><div class="line">const IdToUser = z</div>
<div class="line">  .string()</div>
<div class="line">  .uuid()</div>
<div class="line">  .transform(async (id) =&gt; {</div>
<div class="line">    return await getUserById(id);</div>
<div class="line">  });</div>
</div><!-- fragment --><blockquote class="doxtable">
<p>‚ö†Ô∏è If your schema contains asynchronous transforms, you must use .parseAsync() or .safeParseAsync() to parse data. Otherwise Zod will throw an error. </p>
</blockquote>
<h3 class="doxsection"><a class="anchor" id="autotoc_md7939"></a>
<span class="tt">.default</span></h3>
<p>You can use transforms to implement the concept of "default values" in Zod.</p>
<div class="fragment"><div class="line">const stringWithDefault = z.string().default(&quot;tuna&quot;);</div>
<div class="line"> </div>
<div class="line">stringWithDefault.parse(undefined); // =&gt; &quot;tuna&quot;</div>
</div><!-- fragment --><p>Optionally, you can pass a function into <span class="tt">.default</span> that will be re-executed whenever a default value needs to be generated:</p>
<div class="fragment"><div class="line">const numberWithRandomDefault = z.number().default(Math.random);</div>
<div class="line"> </div>
<div class="line">numberWithRandomDefault.parse(undefined); // =&gt; 0.4413456736055323</div>
<div class="line">numberWithRandomDefault.parse(undefined); // =&gt; 0.1871840107401901</div>
<div class="line">numberWithRandomDefault.parse(undefined); // =&gt; 0.7223408162401552</div>
</div><!-- fragment --><p>Conceptually, this is how Zod processes default values:</p>
<ol type="1">
<li>If the input is <span class="tt">undefined</span>, the default value is returned</li>
<li>Otherwise, the data is parsed using the base schema</li>
</ol>
<h3 class="doxsection"><a class="anchor" id="autotoc_md7940"></a>
<span class="tt">.describe</span></h3>
<p>Use <span class="tt">.describe()</span> to add a <span class="tt">description</span> property to the resulting schema.</p>
<div class="fragment"><div class="line">const documentedString = z</div>
<div class="line">  .string()</div>
<div class="line">  .describe(&quot;A useful bit of text, if you know what to do with it.&quot;);</div>
<div class="line">documentedString.description; // A useful bit of text‚Ä¶</div>
</div><!-- fragment --><p>This can be useful for documenting a field, for example in a JSON Schema using a library like <a href="https://github.com/StefanTerdell/zod-to-json-schema"><span class="tt">zod-to-json-schema</span></a>).</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md7941"></a>
<span class="tt">.catch</span></h3>
<p>Use <span class="tt">.catch()</span> to provide a "catch value" to be returned in the event of a parsing error.</p>
<div class="fragment"><div class="line">const numberWithCatch = z.number().catch(42);</div>
<div class="line"> </div>
<div class="line">numberWithCatch.parse(5); // =&gt; 5</div>
<div class="line">numberWithCatch.parse(&quot;tuna&quot;); // =&gt; 42</div>
</div><!-- fragment --><p>Optionally, you can pass a function into <span class="tt">.catch</span> that will be re-executed whenever a default value needs to be generated. A <span class="tt">ctx</span> object containing the caught error will be passed into this function.</p>
<div class="fragment"><div class="line">const numberWithRandomCatch = z.number().catch((ctx) =&gt; {</div>
<div class="line">  ctx.error; // the caught ZodError</div>
<div class="line">  return Math.random();</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">numberWithRandomCatch.parse(&quot;sup&quot;); // =&gt; 0.4413456736055323</div>
<div class="line">numberWithRandomCatch.parse(&quot;sup&quot;); // =&gt; 0.1871840107401901</div>
<div class="line">numberWithRandomCatch.parse(&quot;sup&quot;); // =&gt; 0.7223408162401552</div>
</div><!-- fragment --><p>Conceptually, this is how Zod processes "catch values":</p>
<ol type="1">
<li>The data is parsed using the base schema</li>
<li>If the parsing fails, the "catch value" is returned</li>
</ol>
<h3 class="doxsection"><a class="anchor" id="autotoc_md7942"></a>
<span class="tt">.optional</span></h3>
<p>A convenience method that returns an optional version of a schema.</p>
<div class="fragment"><div class="line">const optionalString = z.string().optional(); // string | undefined</div>
<div class="line"> </div>
<div class="line">// equivalent to</div>
<div class="line">z.optional(z.string());</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md7943"></a>
<span class="tt">.nullable</span></h3>
<p>A convenience method that returns a nullable version of a schema.</p>
<div class="fragment"><div class="line">const nullableString = z.string().nullable(); // string | null</div>
<div class="line"> </div>
<div class="line">// equivalent to</div>
<div class="line">z.nullable(z.string());</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md7944"></a>
<span class="tt">.nullish</span></h3>
<p>A convenience method that returns a "nullish" version of a schema. Nullish schemas will accept both <span class="tt">undefined</span> and <span class="tt">null</span>. Read more about the concept of "nullish" <a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-7.html#nullish-coalescing">in the TypeScript 3.7 release notes</a>.</p>
<div class="fragment"><div class="line">const nullishString = z.string().nullish(); // string | null | undefined</div>
<div class="line"> </div>
<div class="line">// equivalent to</div>
<div class="line">z.string().nullable().optional();</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md7945"></a>
<span class="tt">.array</span></h3>
<p>A convenience method that returns an array schema for the given type:</p>
<div class="fragment"><div class="line">const stringArray = z.string().array(); // string[]</div>
<div class="line"> </div>
<div class="line">// equivalent to</div>
<div class="line">z.array(z.string());</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md7946"></a>
<span class="tt">.promise</span></h3>
<p>A convenience method for promise types:</p>
<div class="fragment"><div class="line">const stringPromise = z.string().promise(); // Promise&lt;string&gt;</div>
<div class="line"> </div>
<div class="line">// equivalent to</div>
<div class="line">z.promise(z.string());</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md7947"></a>
<span class="tt">.or</span></h3>
<p>A convenience method for union types.</p>
<div class="fragment"><div class="line">const stringOrNumber = z.string().or(z.number()); // string | number</div>
<div class="line"> </div>
<div class="line">// equivalent to</div>
<div class="line">z.union([z.string(), z.number()]);</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md7948"></a>
<span class="tt">.and</span></h3>
<p>A convenience method for creating intersection types.</p>
<div class="fragment"><div class="line">const nameAndAge = z</div>
<div class="line">  .object({ name: z.string() })</div>
<div class="line">  .and(z.object({ age: z.number() })); // { name: string } &amp; { age: number }</div>
<div class="line"> </div>
<div class="line">// equivalent to</div>
<div class="line">z.intersection(z.object({ name: z.string() }), z.object({ age: z.number() }));</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md7949"></a>
<span class="tt">.brand</span></h3>
<p><span class="tt">.brand&lt;T&gt;() =&gt; ZodBranded&lt;this, B&gt;</span></p>
<p>TypeScript's type system is structural, which means that any two types that are structurally equivalent are considered the same.</p>
<div class="fragment"><div class="line">type Cat = { name: string };</div>
<div class="line">type Dog = { name: string };</div>
<div class="line"> </div>
<div class="line">const petCat = (cat: Cat) =&gt; {};</div>
<div class="line">const fido: Dog = { name: &quot;fido&quot; };</div>
<div class="line">petCat(fido); // works fine</div>
</div><!-- fragment --><p>In some cases, its can be desirable to simulate <em>nominal typing</em> inside TypeScript. For instance, you may wish to write a function that only accepts an input that has been validated by Zod. This can be achieved with <em>branded types</em> (AKA <em>opaque types</em>).</p>
<div class="fragment"><div class="line">const Cat = z.object({ name: z.string() }).brand&lt;&quot;Cat&quot;&gt;();</div>
<div class="line">type Cat = z.infer&lt;typeof Cat&gt;;</div>
<div class="line"> </div>
<div class="line">const petCat = (cat: Cat) =&gt; {};</div>
<div class="line"> </div>
<div class="line">// this works</div>
<div class="line">const simba = Cat.parse({ name: &quot;simba&quot; });</div>
<div class="line">petCat(simba);</div>
<div class="line"> </div>
<div class="line">// this doesn&#39;t</div>
<div class="line">petCat({ name: &quot;fido&quot; });</div>
</div><!-- fragment --><p>Under the hood, this works by attaching a "brand" to the inferred type using an intersection type. This way, plain/unbranded data structures are no longer assignable to the inferred type of the schema.</p>
<div class="fragment"><div class="line">const Cat = z.object({ name: z.string() }).brand&lt;&quot;Cat&quot;&gt;();</div>
<div class="line">type Cat = z.infer&lt;typeof Cat&gt;;</div>
<div class="line">// {name: string} &amp; {[symbol]: &quot;Cat&quot;}</div>
</div><!-- fragment --><p>Note that branded types do not affect the runtime result of <span class="tt">.parse</span>. It is a static-only construct.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md7950"></a>
<span class="tt">.readonly</span></h3>
<p><span class="tt">.readonly() =&gt; ZodReadonly&lt;this&gt;</span></p>
<p>This method returns a <span class="tt">ZodReadonly</span> schema instance that parses the input using the base schema, then calls <span class="tt">Object.freeze()</span> on the result. The inferred type is also marked as <span class="tt">readonly</span>.</p>
<div class="fragment"><div class="line">const schema = z.object({ name: z.string() }).readonly();</div>
<div class="line">type schema = z.infer&lt;typeof schema&gt;;</div>
<div class="line">// Readonly&lt;{name: string}&gt;</div>
<div class="line"> </div>
<div class="line">const result = schema.parse({ name: &quot;fido&quot; });</div>
<div class="line">result.name = &quot;simba&quot;; // error</div>
</div><!-- fragment --><p>The inferred type uses TypeScript's built-in readonly types when relevant.</p>
<div class="fragment"><div class="line">z.array(z.string()).readonly();</div>
<div class="line">// readonly string[]</div>
<div class="line"> </div>
<div class="line">z.tuple([z.string(), z.number()]).readonly();</div>
<div class="line">// readonly [string, number]</div>
<div class="line"> </div>
<div class="line">z.map(z.string(), z.date()).readonly();</div>
<div class="line">// ReadonlyMap&lt;string, Date&gt;</div>
<div class="line"> </div>
<div class="line">z.set(z.string()).readonly();</div>
<div class="line">// ReadonlySet&lt;string&gt;</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md7951"></a>
<span class="tt">.pipe</span></h3>
<p>Schemas can be chained into validation "pipelines". It's useful for easily validating the result after a <span class="tt">.transform()</span>:</p>
<div class="fragment"><div class="line">z.string()</div>
<div class="line">  .transform((val) =&gt; val.length)</div>
<div class="line">  .pipe(z.number().min(5));</div>
</div><!-- fragment --><p>The <span class="tt">.pipe()</span> method returns a <span class="tt">ZodPipeline</span> instance.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md7952"></a>
You can use <span class="tt">.pipe()</span> to fix common issues with <span class="tt">z.coerce</span>.</h4>
<p>You can constrain the input to types that work well with your chosen coercion. Then use <span class="tt">.pipe()</span> to apply the coercion.</p>
<p>without constrained input:</p>
<div class="fragment"><div class="line">const toDate = z.coerce.date();</div>
<div class="line"> </div>
<div class="line">// works intuitively</div>
<div class="line">console.log(toDate.safeParse(&quot;2023-01-01&quot;).success); // true</div>
<div class="line"> </div>
<div class="line">// might not be what you want</div>
<div class="line">console.log(toDate.safeParse(null).success); // true</div>
</div><!-- fragment --><p>with constrained input:</p>
<div class="fragment"><div class="line">const datelike = z.union([z.number(), z.string(), z.date()]);</div>
<div class="line">const datelikeToDate = datelike.pipe(z.coerce.date());</div>
<div class="line"> </div>
<div class="line">// still works intuitively</div>
<div class="line">console.log(datelikeToDate.safeParse(&quot;2023-01-01&quot;).success); // true</div>
<div class="line"> </div>
<div class="line">// more likely what you want</div>
<div class="line">console.log(datelikeToDate.safeParse(null).success); // false</div>
</div><!-- fragment --><p>You can also use this technique to avoid coercions that throw uncaught errors.</p>
<p>without constrained input:</p>
<div class="fragment"><div class="line">const toBigInt = z.coerce.bigint();</div>
<div class="line"> </div>
<div class="line">// works intuitively</div>
<div class="line">console.log(toBigInt.safeParse(&quot;42&quot;)); // true</div>
<div class="line"> </div>
<div class="line">// probably not what you want</div>
<div class="line">console.log(toBigInt.safeParse(null)); // throws uncaught error</div>
</div><!-- fragment --><p>with constrained input:</p>
<div class="fragment"><div class="line">const toNumber = z.number().or(z.string()).pipe(z.coerce.number());</div>
<div class="line">const toBigInt = z.bigint().or(toNumber).pipe(z.coerce.bigint());</div>
<div class="line"> </div>
<div class="line">// still works intuitively</div>
<div class="line">console.log(toBigInt.safeParse(&quot;42&quot;).success); // true</div>
<div class="line"> </div>
<div class="line">// error handled by zod, more likely what you want</div>
<div class="line">console.log(toBigInt.safeParse(null).success); // false</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md7953"></a>
Guides and concepts</h2>
<h3 class="doxsection"><a class="anchor" id="autotoc_md7954"></a>
Type inference</h3>
<p>You can extract the TypeScript type of any schema with <span class="tt">z.infer&lt;typeof mySchema&gt;</span> .</p>
<div class="fragment"><div class="line">const A = z.string();</div>
<div class="line">type A = z.infer&lt;typeof A&gt;; // string</div>
<div class="line"> </div>
<div class="line">const u: A = 12; // TypeError</div>
<div class="line">const u: A = &quot;asdf&quot;; // compiles</div>
</div><!-- fragment --><p><b>What about transforms?</b></p>
<p>In reality each Zod schema internally tracks <b>two</b> types: an input and an output. For most schemas (e.g. <span class="tt">z.string()</span>) these two are the same. But once you add transforms into the mix, these two values can diverge. For instance <span class="tt">z.string().transform(val =&gt; val.length)</span> has an input of <span class="tt">string</span> and an output of <span class="tt">number</span>.</p>
<p>You can separately extract the input and output types like so:</p>
<div class="fragment"><div class="line">const stringToNumber = z.string().transform((val) =&gt; val.length);</div>
<div class="line"> </div>
<div class="line">// ‚ö†Ô∏è Important: z.infer returns the OUTPUT type!</div>
<div class="line">type input = z.input&lt;typeof stringToNumber&gt;; // string</div>
<div class="line">type output = z.output&lt;typeof stringToNumber&gt;; // number</div>
<div class="line"> </div>
<div class="line">// equivalent to z.output!</div>
<div class="line">type inferred = z.infer&lt;typeof stringToNumber&gt;; // number</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md7955"></a>
Writing generic functions</h3>
<p>With TypeScript generics, you can write reusable functions that accept Zod schemas as parameters. This enables you to create custom validation logic, schema transformations, and more, while maintaining type safety and inference.</p>
<p>When attempting to write a function that accepts a Zod schema as an input, it's tempting to try something like this:</p>
<div class="fragment"><div class="line">function inferSchema&lt;T&gt;(schema: z.ZodType&lt;T&gt;) {</div>
<div class="line">  return schema;</div>
<div class="line">}</div>
</div><!-- fragment --><p>This approach is incorrect, and limits TypeScript's ability to properly infer the argument. No matter what you pass in, the type of <span class="tt">schema</span> will be an instance of <span class="tt">ZodType</span>.</p>
<div class="fragment"><div class="line">inferSchema(z.string());</div>
<div class="line">// =&gt; ZodType&lt;string&gt;</div>
</div><!-- fragment --><p>This approach loses type information, namely <em>which subclass</em> the input actually is (in this case, <span class="tt">ZodString</span>). That means you can't call any string-specific methods like <span class="tt">.min()</span> on the result of <span class="tt">inferSchema</span>.</p>
<p>A better approach is to infer <em>the schema as a whole</em> instead of merely its inferred type. You can do this with a utility type called <span class="tt">z.ZodTypeAny</span>.</p>
<div class="fragment"><div class="line">function inferSchema&lt;T extends z.ZodTypeAny&gt;(schema: T) {</div>
<div class="line">  return schema;</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">inferSchema(z.string());</div>
<div class="line">// =&gt; ZodString</div>
</div><!-- fragment --><blockquote class="doxtable">
<p><span class="tt">ZodTypeAny</span> is just a shorthand for <span class="tt">ZodType&lt;any, any, any&gt;</span>, a type that is broad enough to match any Zod schema. </p>
</blockquote>
<p>The Result is now fully and properly typed, and the type system can infer the specific subclass of the schema.</p>
<h4 class="doxsection"><a class="anchor" id="autotoc_md7956"></a>
Inferring the inferred type</h4>
<p>If you follow the best practice of using <span class="tt">z.ZodTypeAny</span> as the generic parameter for your schema, you may encounter issues with the parsed data being typed as <span class="tt">any</span> instead of the inferred type of the schema.</p>
<div class="fragment"><div class="line">function parseData&lt;T extends z.ZodTypeAny&gt;(data: unknown, schema: T) {</div>
<div class="line">  return schema.parse(data);</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">parseData(&quot;sup&quot;, z.string());</div>
<div class="line">// =&gt; any</div>
</div><!-- fragment --><p>Due to how TypeScript inference works, it is treating <span class="tt">schema</span> like a <span class="tt">ZodTypeAny</span> instead of the inferred type. You can fix this with a type cast using <span class="tt">z.infer</span>.</p>
<div class="fragment"><div class="line">function parseData&lt;T extends z.ZodTypeAny&gt;(data: unknown, schema: T) {</div>
<div class="line">  return schema.parse(data) as z.infer&lt;T&gt;;</div>
<div class="line">  //                        ^^^^^^^^^^^^^^ &lt;- add this</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">parseData(&quot;sup&quot;, z.string());</div>
<div class="line">// =&gt; string</div>
</div><!-- fragment --><h4 class="doxsection"><a class="anchor" id="autotoc_md7957"></a>
Constraining allowable inputs</h4>
<p>The <span class="tt">ZodType</span> class has three generic parameters.</p>
<div class="fragment"><div class="line">class ZodType&lt;</div>
<div class="line">  Output = any,</div>
<div class="line">  Def extends ZodTypeDef = ZodTypeDef,</div>
<div class="line">  Input = Output</div>
<div class="line">&gt; { ... }</div>
</div><!-- fragment --><p>By constraining these in your generic input, you can limit what schemas are allowable as inputs to your function:</p>
<div class="fragment"><div class="line">function makeSchemaOptional&lt;T extends z.ZodType&lt;string&gt;&gt;(schema: T) {</div>
<div class="line">  return schema.optional();</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">makeSchemaOptional(z.string());</div>
<div class="line">// works fine</div>
<div class="line"> </div>
<div class="line">makeSchemaOptional(z.number());</div>
<div class="line">// Error: &#39;ZodNumber&#39; is not assignable to parameter of type &#39;ZodType&lt;string, ZodTypeDef, string&gt;&#39;</div>
</div><!-- fragment --><h3 class="doxsection"><a class="anchor" id="autotoc_md7958"></a>
Error handling</h3>
<p>Zod provides a subclass of Error called <span class="tt">ZodError</span>. ZodErrors contain an <span class="tt">issues</span> array containing detailed information about the validation problems.</p>
<div class="fragment"><div class="line">const result = z</div>
<div class="line">  .object({</div>
<div class="line">    name: z.string(),</div>
<div class="line">  })</div>
<div class="line">  .safeParse({ name: 12 });</div>
<div class="line"> </div>
<div class="line">if (!result.success) {</div>
<div class="line">  result.error.issues;</div>
<div class="line">  /* [</div>
<div class="line">      {</div>
<div class="line">        &quot;code&quot;: &quot;invalid_type&quot;,</div>
<div class="line">        &quot;expected&quot;: &quot;string&quot;,</div>
<div class="line">        &quot;received&quot;: &quot;number&quot;,</div>
<div class="line">        &quot;path&quot;: [ &quot;name&quot; ],</div>
<div class="line">        &quot;message&quot;: &quot;Expected string, received number&quot;</div>
<div class="line">      }</div>
<div class="line">  ] */</div>
<div class="line">}</div>
</div><!-- fragment --><blockquote class="doxtable">
<p>For detailed information about the possible error codes and how to customize error messages, check out the dedicated error handling guide: ERROR_HANDLING.md </p>
</blockquote>
<p>Zod's error reporting emphasizes <em>completeness</em> and <em>correctness</em>. If you are looking to present a useful error message to the end user, you should either override Zod's error messages using an error map (described in detail in the Error Handling guide) or use a third-party library like <a href="https://github.com/causaly/zod-validation-error"><span class="tt">zod-validation-error</span></a></p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md7959"></a>
Error formatting</h3>
<p>You can use the <span class="tt">.format()</span> method to convert this error into a nested object.</p>
<div class="fragment"><div class="line">const result = z</div>
<div class="line">  .object({</div>
<div class="line">    name: z.string(),</div>
<div class="line">  })</div>
<div class="line">  .safeParse({ name: 12 });</div>
<div class="line"> </div>
<div class="line">if (!result.success) {</div>
<div class="line">  const formatted = result.error.format();</div>
<div class="line">  /* {</div>
<div class="line">    name: { _errors: [ &#39;Expected string, received number&#39; ] }</div>
<div class="line">  } */</div>
<div class="line"> </div>
<div class="line">  formatted.name?._errors;</div>
<div class="line">  // =&gt; [&quot;Expected string, received number&quot;]</div>
<div class="line">}</div>
</div><!-- fragment --><h2 class="doxsection"><a class="anchor" id="autotoc_md7960"></a>
Comparison</h2>
<p>There are a handful of other widely-used validation libraries, but all of them have certain design limitations that make for a non-ideal developer experience.</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md7961"></a>
Joi</h3>
<p><a href="https://github.com/hapijs/joi">https://github.com/hapijs/joi</a></p>
<p>Doesn't support static type inference üòï</p>
<h3 class="doxsection"><a class="anchor" id="autotoc_md7962"></a>
Yup</h3>
<p><a href="https://github.com/jquense/yup">https://github.com/jquense/yup</a></p>
<p>Yup is a full-featured library that was implemented first in vanilla JS, and later rewritten in TypeScript.</p>
<ul>
<li>Supports casting and transforms</li>
<li>All object fields are optional by default</li>
<li>Missing promise schemas</li>
<li>Missing function schemas</li>
<li>Missing union &amp; intersection schemas</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md7963"></a>
io-ts</h3>
<p><a href="https://github.com/gcanti/io-ts">https://github.com/gcanti/io-ts</a></p>
<p>io-ts is an excellent library by gcanti. The API of io-ts heavily inspired the design of Zod.</p>
<p>In our experience, io-ts prioritizes functional programming purity over developer experience in many cases. This is a valid and admirable design goal, but it makes io-ts particularly hard to integrate into an existing codebase with a more procedural or object-oriented bias. For instance, consider how to define an object with optional properties in io-ts:</p>
<div class="fragment"><div class="line">import * as t from &quot;io-ts&quot;;</div>
<div class="line"> </div>
<div class="line">const A = t.type({</div>
<div class="line">  foo: t.string,</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">const B = t.partial({</div>
<div class="line">  bar: t.number,</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">const C = t.intersection([A, B]);</div>
<div class="line"> </div>
<div class="line">type C = t.TypeOf&lt;typeof C&gt;;</div>
<div class="line">// returns { foo: string; bar?: number | undefined }</div>
</div><!-- fragment --><p>You must define the required and optional props in separate object validators, pass the optionals through <span class="tt">t.partial</span> (which marks all properties as optional), then combine them with <span class="tt">t.intersection</span> .</p>
<p>Consider the equivalent in Zod:</p>
<div class="fragment"><div class="line">const C = z.object({</div>
<div class="line">  foo: z.string(),</div>
<div class="line">  bar: z.number().optional(),</div>
<div class="line">});</div>
<div class="line"> </div>
<div class="line">type C = z.infer&lt;typeof C&gt;;</div>
<div class="line">// returns { foo: string; bar?: number | undefined }</div>
</div><!-- fragment --><p>This more declarative API makes schema definitions vastly more concise.</p>
<p><span class="tt">io-ts</span> also requires the use of gcanti's functional programming library <span class="tt">fp-ts</span> to parse results and handle errors. This is another fantastic resource for developers looking to keep their codebase strictly functional. But depending on <span class="tt">fp-ts</span> necessarily comes with a lot of intellectual overhead; a developer has to be familiar with functional programming concepts and the <span class="tt">fp-ts</span> nomenclature to use the library.</p>
<ul>
<li>Supports codecs with serialization &amp; deserialization transforms</li>
<li>Supports branded types</li>
<li>Supports advanced functional programming, higher-kinded types, <span class="tt">fp-ts</span> compatibility</li>
<li>Missing object methods: (pick, omit, partial, deepPartial, merge, extend)</li>
<li>Missing nonempty arrays with proper typing (<span class="tt">[T, ...T[]]</span>)</li>
<li>Missing promise schemas</li>
<li>Missing function schemas</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md7964"></a>
Runtypes</h3>
<p><a href="https://github.com/pelotom/runtypes">https://github.com/pelotom/runtypes</a></p>
<p>Good type inference support.</p>
<ul>
<li>Supports "pattern matching": computed properties that distribute over unions</li>
<li>Missing object methods: (deepPartial, merge)</li>
<li>Missing nonempty arrays with proper typing (<span class="tt">[T, ...T[]]</span>)</li>
<li>Missing promise schemas</li>
<li>Missing error customization</li>
</ul>
<h3 class="doxsection"><a class="anchor" id="autotoc_md7965"></a>
Ow</h3>
<p><a href="https://github.com/sindresorhus/ow">https://github.com/sindresorhus/ow</a></p>
<p>Ow is focused on function input validation. It's a library that makes it easy to express complicated assert statements, but it doesn't let you parse untyped data. They support a much wider variety of types; Zod has a nearly one-to-one mapping with TypeScript's type system, whereas ow lets you validate several highly-specific types out of the box (e.g. <span class="tt">int32Array</span> , see full list in their README).</p>
<p>If you want to validate function inputs, use function schemas in Zod! It's a much simpler approach that lets you reuse a function type declaration without repeating yourself (namely, copy-pasting a bunch of ow assertions at the beginning of every function). Also Zod lets you validate your return types as well, so you can be sure there won't be any unexpected data passed downstream.</p>
<h2 class="doxsection"><a class="anchor" id="autotoc_md7966"></a>
Changelog</h2>
<p>View the changelog at CHANGELOG.md </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>Users</b></li><li class="navelem"><b>annaa</b></li><li class="navelem"><b>OneDrive</b></li><li class="navelem"><b>Desktop</b></li><li class="navelem"><b>sdv-gestion-academica</b></li><li class="navelem"><a href="dir_787bcb4c37183ee48968c83c92947891.html">sdv-frontend</a></li><li class="navelem"><b>node_modules</b></li><li class="navelem"><a href="dir_0328c5866053b935528d6ba1a92bb593.html">zod</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.16.1 </li>
  </ul>
</div>
</body>
</html>
